# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2021 DaoAI Robotics Inc.
# This file is distributed under the same license as the DaoAI Vision User
# Manual package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: DaoAI Vision User Manual \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-05-26 15:26-0700\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"

#: ../nodes/3D Processing/3d_object_finder.rst:2
msgid "3d Object Finder Node"
msgstr ""

#: ../nodes/3D Processing/3d_object_finder.rst:4
msgid ""
"This node is used to find 3d locations of an object using point cloud "
"features related algorithms. At the creation of the node, users need to "
"select which type of point cloud features to use (normal or edge mode)."
msgstr ""

#: ../nodes/3D ../nodes/Calibration/calibration_2d_overview.rst:2
#: ../nodes/Calibration/calibration_overview.rst:2
#: ../nodes/Calibration/hand_eye_calibration_2d_v02_overview.rst:2
#: ../nodes/Calibration/pose_generation_overview.rst:2
#: ../nodes/Calibration/sphere_calibration_overview.rst:2 ../nodes/DA
#: ../nodes/Flowchart_control/Break ../nodes/Image Finder Modules/Mod
#: Modules/code_reader_overview.rst:2 Modules/color_checker_overview.rst:2
#: Modules/da_alignment_overview.rst:2 Modules/da_calibration_overview.rst:2
#: Modules/da_cloudndepth_overview.rst:2 Modules/measurement_overview.rst:2
#: Modules/metrology_overview.rst:2 Modules/mono_3d_overview.rst:2
#: Modules/shape_finder_overview.rst:2 Node.rst:5
#: Processing/3d_object_finder_overview.rst:2
#: Processing/alignment_overview.rst:2 Processing/box_vol_est_overview.rst:2
#: Processing/cloud_process_overview.rst:2
#: Processing/dl_classify_overview.rst:3 Processing/dl_segment_overview.rst:2
#: Processing/image_process_overview.rst:2
#: Processing/pick_adjust_overview.rst:2 Processing/reconstruct_overview.rst:2
#: Processing/scene_crop_overview.rst:2 Processing/segmentation_overview.rst:2
#: Processing/verification_overview.rst:2
msgid "Overview"
msgstr ""

#: ../nodes/3D ../nodes/Calibration/pose_generation_overview.rst:14 ../nodes/DA
#: ../nodes/Flowchart_control/Break ../nodes/Flowchart_control/Condition
#: ../nodes/Flowchart_control/Constant ../nodes/Flowchart_control/Continue
#: ../nodes/Flowchart_control/Flowchart ../nodes/Flowchart_control/Halt
#: ../nodes/Flowchart_control/Switch ../nodes/Image ../nodes/Utility/bag.rst:15
#: ../nodes/Utility/bag.rst:39 ../nodes/Utility/load_recipe.rst:12
#: ../nodes/Utility/pose.rst:15 ../nodes/Utility/pose.rst:34
#: ../nodes/Utility/reader_writer.rst:64
#: ../nodes/Utility/transformation_tree.rst:12 Finder Modules/Mod
#: Modules/da_alignment_overview.rst:5 Modules/da_cloudndepth_overview.rst:5
#: Node.rst:14 Node.rst:19 Node.rst:20 Node.rst:22 Node.rst:24 Node.rst:40
#: Node.rst:42 Processing/3d_object_finder_overview.rst:5
#: Processing/alignment_overview.rst:5 Processing/box_vol_est_overview.rst:5
#: Processing/cloud_process_overview.rst:5
#: Processing/dl_classify_overview.rst:6 Processing/dl_segment_overview.rst:5
#: Processing/image_process_overview.rst:5 Processing/mesh_process.rst:21
#: Processing/pallet_loading.rst:25 Processing/pick_adjust_overview.rst:5
#: Processing/reconstruct_overview.rst:5 Processing/scene_crop_overview.rst:5
#: Processing/segmentation_overview.rst:5
#: Processing/verification_overview.rst:5 Processing/visualization.rst:11
msgid "Input"
msgstr ""

#: ../nodes/3D Processing/3d_object_finder_overview.rst:6
msgid "Scene cloud: one or a vector of point clouds to find objects within."
msgstr ""

#: ../nodes/3D ../nodes/Calibration/pose_generation_overview.rst:21 ../nodes/DA
#: ../nodes/Flowchart_control/Break ../nodes/Flowchart_control/Condition
#: ../nodes/Flowchart_control/Constant ../nodes/Flowchart_control/Continue
#: ../nodes/Flowchart_control/Flowchart ../nodes/Flowchart_control/Halt
#: ../nodes/Flowchart_control/Loop ../nodes/Flowchart_control/Switch
#: ../nodes/Image ../nodes/Utility/reader_writer.rst:48
#: ../nodes/Utility/transformation_tree.rst:21 Finder Modules/Mod
#: Modules/code_reader_overview.rst:75 Modules/color_checker_overview.rst:61
#: Modules/da_alignment_overview.rst:11 Modules/da_cloudndepth_overview.rst:27
#: Modules/measurement_overview.rst:39 Modules/metrology_overview.rst:16
#: Modules/mono_3d_overview.rst:61 Modules/shape_finder_overview.rst:39
#: Node.rst:20 Node.rst:25 Node.rst:26 Node.rst:27 Node.rst:28 Node.rst:30
#: Node.rst:32 Node.rst:51 Processing/3d_object_finder_overview.rst:9
#: Processing/alignment_overview.rst:12 Processing/box_vol_est_overview.rst:11
#: Processing/cloud_process_overview.rst:10
#: Processing/dl_classify_overview.rst:12 Processing/dl_segment_overview.rst:11
#: Processing/image_process_overview.rst:10 Processing/mesh_process.rst:26
#: Processing/pallet_loading.rst:30 Processing/pick_adjust_overview.rst:12
#: Processing/reconstruct_overview.rst:13 Processing/scene_crop_overview.rst:11
#: Processing/segmentation_overview.rst:12
#: Processing/verification_overview.rst:12
msgid "Output"
msgstr ""

#: ../nodes/3D Processing/3d_object_finder_overview.rst:11
msgid "cloudModel: active model used for searching, represented as point cloud"
msgstr ""

#: ../nodes/3D Processing/3d_object_finder_overview.rst:12
msgid ""
"edgesModel: active model used for searching, represented as edge cloud. "
"Available only in edge mode"
msgstr ""

#: ../nodes/3D Processing/3d_object_finder_overview.rst:13
msgid ""
"msehModel: active model used for searching, represented as mesh. "
"Available only when the model is defined by mesh"
msgstr ""

#: ../nodes/3D Processing/3d_object_finder_overview.rst:14
msgid "resultPoses: a vector of pose representing the result of search"
msgstr ""

#: ../nodes/3D Processing/3d_object_finder_overview.rst:15
msgid ""
"success: a field indicating whether the search is successful (at least "
"one position found)"
msgstr ""

#: ../nodes/3D Processing/3d_object_finder_parameter_tune.rst:2
msgid "Parameter Tunning Guide"
msgstr ""

#: ../nodes/3D Processing/3d_object_finder_parameter_tune.rst:4
msgid ""
"This guide will walk through some rules of thumb when it comes to "
"adjusting parameters to get better detection."
msgstr ""

#: ../nodes/3D Processing/3d_object_finder_parameter_tune.rst:7
msgid "Not detection all objects"
msgstr ""

#: ../nodes/3D Processing/3d_object_finder_parameter_tune.rst:9
msgid ""
"Increase the search detail. This will increase the number of computed "
"scene features"
msgstr ""

#: ../nodes/3D Processing/3d_object_finder_parameter_tune.rst:10
msgid ""
"Decrease acceptance threshold. This lowers the acceptance threshold of "
"the score filter, keeping poses with lower scores"
msgstr ""

#: ../nodes/3D Processing/3d_object_finder_parameter_tune.rst:25
msgid "False positive"
msgstr ""

#: ../nodes/3D Processing/3d_object_finder_parameter_tune.rst:27
msgid ""
"Reduce downsample strength. This makes the downsample voxel size smaller,"
" preserving more detail in the scene. Reducing downsample strength can "
"also improve poses that are badly oriented."
msgstr ""

#: ../nodes/3D Processing/3d_object_finder_parameter_tune.rst:32
#: Processing/3d_object_finder_parameter_tune.rst:59
msgid "downsample strength low"
msgstr ""

#: ../nodes/3D Processing/3d_object_finder_parameter_tune.rst:37
#: Processing/3d_object_finder_parameter_tune.rst:64
msgid "downsample strength medium"
msgstr ""

#: ../nodes/3D Processing/3d_object_finder_parameter_tune.rst:40
msgid "Model parameters"
msgstr ""

#: ../nodes/3D Processing/3d_object_finder_parameter_tune.rst:42
msgid ""
"Adjust model feature detail. Increasing model feature detail will "
"increase the amount of model features calculated, making it more likely "
"to accurately find the object in the scene"
msgstr ""

#: ../nodes/3D Processing/3d_object_finder_parameter_tune.rst:43
msgid ""
"Adjust model downsample strength. Reducing downsample strength can remove"
" false positives"
msgstr ""

#: ../nodes/3D Processing/3d_object_finder_parameter_tune.rst:49
msgid "feature detail low"
msgstr ""

#: ../nodes/3D Processing/3d_object_finder_parameter_tune.rst:54
msgid "feature detail high"
msgstr ""

#: ../nodes/3D Processing/3d_object_finder_procedure.rst:2
msgid "Procedure for Using 3d Object Finder Node"
msgstr ""

#: ../nodes/3D Processing/3d_object_finder_procedure.rst:4
msgid "Pre-process scene point cloud (only in edge mode)"
msgstr ""

#: ../nodes/3D Processing/3d_object_finder_procedure.rst:5
msgid "Define model"
msgstr ""

#: ../nodes/3D Processing/3d_object_finder_procedure.rst:6
msgid "Search model"
msgstr ""

#: ../nodes/3D Processing/3d_object_finder_procedure.rst:7
msgid "Use result to compute picking poses"
msgstr ""

#: ../nodes/3D Processing/3d_object_finder_procedure.rst:11
msgid "Pre-process Point Cloud In Edge Mode"
msgstr ""

#: ../nodes/3D Processing/3d_object_finder_procedure.rst:13
msgid ""
"To get proper search result using edge point, the scene cloud must be "
"pre-process to contain normals. This is because after edge extraction is "
"performed on point cloud it will be very hard to compute its normals, "
"which are used in searching. Simply use cloud process node's normal "
"operation to pre-process the point cloud"
msgstr ""

#: ../nodes/3D Processing/3d_object_finder_procedure.rst:16
msgid ""
"Before you can see the nodes detailed config, you need to set the search "
"type of the node to be either normal or edge."
msgstr ""

#: ../nodes/3D Processing/3d_object_finder_procedure.rst:19
msgid "Model Creation and Processing"
msgstr ""

#: ../nodes/3D Processing/3d_object_finder_procedure.rst:24
msgid ""
"Then in the model section, users are able to add/delete model, the "
"dropdown list on the bottom shows the current active model to search. You"
" can also double click model entry to edit model. You will see a model "
"config page, where you are able to see the model and adjust its "
"parameters."
msgstr ""

#: ../nodes/3D Processing/3d_object_finder_procedure.rst:33
msgid "Model Parameters:"
msgstr ""

#: ../nodes/3D Processing/3d_object_finder_procedure.rst:35
msgid "Define type"
msgstr ""

#: ../nodes/3D
msgid "int"
msgstr ""

#: ../nodes/3D Processing/3d_object_finder_procedure.rst:36
msgid "How the model will be defined, either “from mesh” or “from scene”"
msgstr ""

#: ../nodes/3D Processing/3d_object_finder_procedure.rst:37
msgid "Mesh path"
msgstr ""

#: ../nodes/3D
msgid "string"
msgstr ""

#: ../nodes/3D Processing/3d_object_finder_procedure.rst:38
msgid "Mesh path used when define type is “from mesh”"
msgstr ""

#: ../nodes/3D Processing/3d_object_finder_procedure.rst:39
msgid "Export path"
msgstr ""

#: ../nodes/3D Processing/3d_object_finder_procedure.rst:40
msgid "Path used when exporting the model"
msgstr ""

#: ../nodes/3D Processing/3d_object_finder_procedure.rst:41
msgid "Feature detail"
msgstr ""

#: ../nodes/3D Processing/3d_object_finder_procedure.rst:42
msgid "Controls the amount of model features calculated"
msgstr ""

#: ../nodes/3D Processing/3d_object_finder_procedure.rst:43
#: Processing/3d_object_finder_procedure.rst:91
msgid "Downsample strength"
msgstr ""

#: ../nodes/3D Processing/3d_object_finder_procedure.rst:44
msgid "Controls the strength of the downsample filter applied to the model"
msgstr ""

#: ../nodes/3D Processing/3d_object_finder_procedure.rst:45
msgid "use search region"
msgstr ""

#: ../nodes/3D ../nodes/Flowchart_control/Break Node.rst:44
msgid "bool"
msgstr ""

#: ../nodes/3D Processing/3d_object_finder_procedure.rst:46
msgid "Controls whether to use the user-defined search region"
msgstr ""

#: ../nodes/3D Processing/3d_object_finder_procedure.rst:47
msgid "constrain x-axis/y-axis/z-axis rotation"
msgstr ""

#: ../nodes/3D Processing/3d_object_finder_procedure.rst:48
msgid ""
"Controls whether to enable x/y/z axis rotation constraints when searching"
" for object poses"
msgstr ""

#: ../nodes/3D Processing/3d_object_finder_procedure.rst:49
msgid "min angle"
msgstr ""

#: ../nodes/3D
msgid "double"
msgstr ""

#: ../nodes/3D Processing/3d_object_finder_procedure.rst:50
msgid ""
"Minimum rotation angle about the x/y/z axis when searching for object "
"poses"
msgstr ""

#: ../nodes/3D Processing/3d_object_finder_procedure.rst:52
msgid "max angle"
msgstr ""

#: ../nodes/3D Processing/3d_object_finder_procedure.rst:52
msgid ""
"Maximum rotation angle about the x/y/z axis when searching for object "
"poses"
msgstr ""

#: ../nodes/3D Processing/3d_object_finder_procedure.rst:54
msgid ""
"The first way to define a model is to define from a scene point cloud. In"
" model config page, select model type to be \"From scene\", then click "
"\"Define Model\". Then the main window display will prompt a bounding box"
" interactor (or console will give error message if the \"Scene Cloud\" "
"input is not linked or is invalid). Use the bounding box to include the "
"points of the model, then hit 0 or click \"Exit Interactor\" button to "
"save your change. After that the processed model (with default model "
"parameter) will be shown in the config page."
msgstr ""

#: ../nodes/3D Processing/3d_object_finder_procedure.rst:62
msgid ""
"The second way to define a model is to define from a polygon mesh file. "
"In model config page, select model type to be \"From Mesh\", then browse "
"the .ply file and click \"Load Model\"."
msgstr ""

#: ../nodes/3D Processing/3d_object_finder_procedure.rst:65
msgid "Adjust Model Parameters"
msgstr ""

#: ../nodes/3D Processing/3d_object_finder_procedure.rst:67
msgid ""
"After the model is defined users can adjust model parameters in the model"
" config page. The most common adjustment of model parameters are "
"downsample strength and search detail. Remember to click \"Update Model\""
" if these two settings are changed."
msgstr ""

#: ../nodes/3D Processing/3d_object_finder_procedure.rst:70
msgid ""
"You can define search region by checking \"Constrain Search Region\" and "
"use \"Set Search Region\" button. This will enter the interaction mode "
"where you need to draw a bounding box to include the search region, "
"similar to defining a model from scene."
msgstr ""

#: ../nodes/3D Processing/3d_object_finder_procedure.rst:73
msgid ""
"You can also define the range of rotation of the model. Click \"Adjust "
"Pose\" to enter the interaction mode where you can rotate the model "
"around origin by click and drag on the model cloud. This will define a "
"base pose. Then you can specific the X,Y,Z rotation range based on the "
"base pose."
msgstr ""

#: ../nodes/3D Processing/3d_object_finder_procedure.rst:79
msgid "You can also save the model as a pcd file by using export model."
msgstr ""

#: ../nodes/3D Processing/3d_object_finder_procedure.rst:83
msgid "Detect Model in Scene"
msgstr ""

#: ../nodes/3D Processing/3d_object_finder_procedure.rst:85
msgid ""
"After the model is defined you can search the position of the model in "
"scene."
msgstr ""

#: ../nodes/3D Processing/3d_object_finder_procedure.rst:87
msgid "Scene Matching Parameters:"
msgstr ""

#: ../nodes/3D Processing/3d_object_finder_procedure.rst:89
msgid "Selected model"
msgstr ""

#: ../nodes/3D Processing/3d_object_finder_procedure.rst:90
msgid "The name of the model that will be searched for"
msgstr ""

#: ../nodes/3D Processing/3d_object_finder_procedure.rst:92
msgid "Controls the strength of the downsample filter applied to the scene"
msgstr ""

#: ../nodes/3D Processing/3d_object_finder_procedure.rst:93
msgid "Search detail"
msgstr ""

#: ../nodes/3D Processing/3d_object_finder_procedure.rst:94
msgid ""
"Controls the quality of the search. Larger values mean more thorough "
"search."
msgstr ""

#: ../nodes/3D Processing/3d_object_finder_procedure.rst:95
msgid "Object separation"
msgstr ""

#: ../nodes/3D Processing/3d_object_finder_procedure.rst:96
msgid ""
"Controls expected distance between target objects. Larger values mean "
"more separation expected between objects."
msgstr ""

#: ../nodes/3D Processing/3d_object_finder_procedure.rst:97
msgid "Timeout"
msgstr ""

#: ../nodes/3D Processing/3d_object_finder_procedure.rst:98
msgid "Timeout in ms"
msgstr ""

#: ../nodes/3D Processing/3d_object_finder_procedure.rst:100
msgid "Acceptance threshold"
msgstr ""

#: ../nodes/3D Processing/3d_object_finder_procedure.rst:100
msgid "Controls the threshold used when filtering possible poses"
msgstr ""

#: ../nodes/3D Processing/3d_object_finder_procedure.rst:102
msgid ""
"In the display window you can select what to display: use \"Show Model\" "
"to show found occurrence of model in the scene, use \"Show Scene\" to "
"show the scene cloud (in edge mode this will be edge cloud extracted from"
" the original scene cloud), use \"Show Downsampled\" to show the "
"downsampled scene cloud."
msgstr ""

#: ../nodes/3D Processing/3d_object_finder_procedure.rst:110
msgid "Edge Extraction (Only In Edge Mode)"
msgstr ""

#: ../nodes/3D Processing/3d_object_finder_procedure.rst:111
msgid ""
"When the search type is set to Edge, we perform edge extraction on both "
"the model and scene"
msgstr ""

#: ../nodes/3D Processing/3d_object_finder_procedure.rst:113
msgid "Edge Parameters:"
msgstr ""

#: ../nodes/3D Processing/3d_object_finder_procedure.rst:115
msgid "Enable NaN edges : int"
msgstr ""

#: ../nodes/3D Processing/3d_object_finder_procedure.rst:116
msgid "Enable RGB edges : int"
msgstr ""

#: ../nodes/3D Processing/3d_object_finder_procedure.rst:117
msgid "Enable Occluding edges : int"
msgstr ""

#: ../nodes/3D Processing/3d_object_finder_procedure.rst:118
msgid "Enable Depth Edges : int"
msgstr ""

#: ../nodes/3D Processing/3d_object_finder_procedure.rst:119
msgid "rgb detail"
msgstr ""

#: ../nodes/3D Processing/3d_object_finder_procedure.rst:120
msgid "The rgb edge detail level, larger values provide more edges."
msgstr ""

#: ../nodes/3D Processing/3d_object_finder_procedure.rst:121
msgid "depth detail"
msgstr ""

#: ../nodes/3D Processing/3d_object_finder_procedure.rst:122
msgid "The depth edge detail level, larger values provide more edges."
msgstr ""

#: ../nodes/3D Processing/3d_object_finder_procedure.rst:124
msgid "occluding detail"
msgstr ""

#: ../nodes/3D Processing/3d_object_finder_procedure.rst:124
msgid "The occluding edge detail level, larger values provide more edges."
msgstr ""

#: ../nodes/3D Processing/3d_object_finder_procedure.rst:126
msgid ""
"After the edge extraction setting is changed, redefine the model using "
"new edge extraction parameters."
msgstr ""

#: ../nodes/3D Processing/alignment.rst:2
msgid "Alignment Node"
msgstr ""

#: ../nodes/3D Processing/alignment.rst:4
msgid ""
"The Alignment Node uses an iterative algorithm to refine poses for better"
" alignment. Given initial poses, an input model mesh is iteratively "
"aligned toward an input scene cloud by sampling points, matching them "
"between the model and scene, and minimizing the error between matched "
"points. This node should be used when reasonably accurate poses have "
"already been obtained, such as following after the Scene Match Node or "
"Mod Finder Node, in which case these poses can be further refined."
msgstr ""

#: ../nodes/3D Processing/alignment.rst:10
msgid ""
"The alignment node usually follow after a node provides model mesh "
"input(reader, mesh process node), a node provides scene cloud(camera, "
"cloud process node), and a node provides a reasonably good match for "
"further alignment(3d object finder node)."
msgstr ""

#: ../nodes/3D Processing/alignment_overview.rst:7
msgid "Model mesh: a point cloud or mesh, used to align model to scene"
msgstr ""

#: ../nodes/3D Processing/alignment_overview.rst:8
msgid "Scene cloud: a point cloud, represents the scene point cloud"
msgstr ""

#: ../nodes/3D Processing/alignment_overview.rst:9
msgid ""
"Hypothesis: a vector of poses, each pose represents a possible position "
"of the model, the pose has to be relative close to ground truth in order "
"to produce better result"
msgstr ""

#: ../nodes/3D Processing/alignment_overview.rst:13
msgid "Poses: a vector of poses after the alignment"
msgstr ""

#: ../nodes/3D Processing/alignment_overview.rst:16
#: Processing/pallet_loading.rst:34 Processing/pick_adjust_overview.rst:17
#: Processing/scene_crop_overview.rst:17
#: Processing/segmentation_overview.rst:21
#: Processing/verification_overview.rst:17
msgid "Parameters"
msgstr ""

#: ../nodes/3D Processing/alignment_overview.rst:18
msgid ""
"Error Metric: Point-to-point is representative of the true error, while "
"point-to-plane is representative of error relative to orientation. The "
"change of relative pose that gives the minimal point-to-plane error is "
"usually solved using standard nonlinear least-squares methods, which are "
"often very slow. Generally, it is recommend using point to point error "
"metric unless the geometry and amount of overlap between the hypothesis "
"and scene are large to use the point to plane metric."
msgstr ""

#: ../nodes/3D Processing/alignment_overview.rst:19
msgid ""
"Use Model box: Crops the scene based on the model's bounding box before "
"alignment (speeds up matching)"
msgstr ""

#: ../nodes/3D Processing/alignment_overview.rst:20
msgid ""
"Max Iterations: Maximum iteration steps. The higher the number is, the "
"longer it would take for alignment, but the alignment quality will be "
"better with more iteration. Preset values are LOW=10 MEDIUM=50 HIGH=100"
msgstr ""

#: ../nodes/3D Processing/alignment_overview.rst:21
msgid ""
"True Error Tolerance: The error tolerance for coordination difference "
"between the object and the scene. The alignment is more accurate when the"
" tolerance is lower. Preset values are LOW=1 MEDIUM=5 HIGH=10"
msgstr ""

#: ../nodes/3D Processing/alignment_overview.rst:22
msgid ""
"Relative Error Tolerance: The error tolerance for orientation difference "
"between the object and the scene. The alignment is more accurate when the"
" tolerance is lower. Preset values are LOW=0.1 MEDUIM=1 HIGH=10"
msgstr ""

#: ../nodes/3D Processing/alignment_overview.rst:23
msgid ""
"Scene Decimation Step: Step size for sampling points in the scene. The "
"larger the step size means the more points it will skip for the alignment"
" algorithm. Generally, the smaller the step will result in more accuracy."
" Preset Values are LOW=15 MEDIUM=100 HIGH=500"
msgstr ""

#: ../nodes/3D Processing/alignment_overview.rst:24
msgid ""
"Model Decimation Step: Step size for sampling points in the model. This "
"is similar to Scene Decimation Step."
msgstr ""

#: ../nodes/3D Processing/alignment_procedure.rst:2
msgid "Procedure of Using Alignment Node"
msgstr ""

#: ../nodes/3D Processing/alignment_procedure.rst:4
msgid ""
"Get 3d poses of the object (3d object finder node, mod finder node 3d "
"mode, reconstruct node, etc)"
msgstr ""

#: ../nodes/3D Processing/alignment_procedure.rst:5
msgid "Get model point cloud or mesh"
msgstr ""

#: ../nodes/3D Processing/alignment_procedure.rst:6
msgid "Get scene cloud"
msgstr ""

#: ../nodes/3D Processing/alignment_procedure.rst:7
msgid "Run alignment node to improve 3d poses"
msgstr ""

#: ../nodes/3D Processing/alignment_procedure.rst:8
msgid "(Optional) Use verification node to verify the aligned poses"
msgstr ""

#: ../nodes/3D Processing/alignment_procedure.rst:15
msgid "Tips on making alignment result more accurate"
msgstr ""

#: ../nodes/3D Processing/alignment_procedure.rst:17
msgid ""
"Generally, it is recommend using point to point error metric unless the "
"geometry and amount of overlap between the hypothesis and scene are large"
" to use the point to plane metric."
msgstr ""

#: ../nodes/3D Processing/alignment_procedure.rst:18
msgid ""
"Increase max iteration to get better alignment, at the cost of longer "
"running time."
msgstr ""

#: ../nodes/3D Processing/alignment_procedure.rst:19
msgid ""
"Check \"Use Model Box\" to check the scene based on the model's bounding "
"box before alignment (speeds up matching)"
msgstr ""

#: ../nodes/3D Processing/alignment_procedure.rst:20
msgid "Change tolerance"
msgstr ""

#: ../nodes/3D Processing/alignment_procedure.rst:25
msgid "Change decimation step"
msgstr ""

#: ../nodes/3D Processing/box_vol_est.rst:2
msgid "Box Volume Estimation Node"
msgstr ""

#: ../nodes/3D Processing/box_vol_est.rst:4
msgid ""
"The purpose of the box volume estimation node is to analyze a vector of "
"point clouds and generate an estimated length, width, and height of each "
"box, as well as an appropriate picking location. It works by generating a"
" bounding box around the segment such that it is aligned with the "
"specified reference frame, and extending it downwards until it reaches "
"the origin of the reference frame. The node obtains its best results when"
" the segments are rectangular in shape, and are closely aligned to the "
"reference frame. The node does not have any functionality for determining"
" if a segment is “rectangular”, nor does it discriminate from non-"
"rectangular segments (although the results will likely be poor quality)."
msgstr ""

#: ../nodes/3D Processing/box_vol_est.rst:6
msgid ""
"The poses for each box are normally generated at the center of the top "
"face of each box. However, there are many options for customizing how "
"these poses are generated."
msgstr ""

#: ../nodes/3D Processing/box_vol_est_overview.rst:6
msgid ""
"Box segments: a vector of point cloud, usually from segmentation node or "
"DL segmentation node, each contains that point cloud of a box object"
msgstr ""

#: ../nodes/3D Processing/box_vol_est_overview.rst:7
msgid ""
"Origin: a pose representing the position of reference coordinates, all "
"boxes will have its top surface on the x-y plane of the reference "
"coordinates"
msgstr ""

#: ../nodes/3D Processing/box_vol_est_overview.rst:8
msgid ""
"Scene cloud: a point cloud that contain the original scene, used for "
"visualization"
msgstr ""

#: ../nodes/3D Processing/box_vol_est_overview.rst:12
msgid "boxPoses: a vector of poses, representing the picking pose of each box"
msgstr ""

#: ../nodes/3D Processing/box_vol_est_overview.rst:13
msgid "dimensions: a vector of triples, representing the picking"
msgstr ""

#: ../nodes/3D Processing/box_vol_est_overview.rst:16
msgid "Node Parameters"
msgstr ""

#: ../nodes/3D Processing/box_vol_est_overview.rst:18
msgid ""
"Use OBB: Choose the kind of bounding box. If unselected, box will be "
"oriented in line with the computer axes. If selected, bounding box will "
"be perpendicular to the cloud's eigenvectors, which are shown visually "
"through the pose direction. In both cases, the reference frame is "
"accounted for."
msgstr ""

#: ../nodes/3D Processing/box_vol_est_overview.rst:18
msgid ""
"Use 2d Correction: whether to use 2d information to correct rotation "
"around z axis for the box position and picking pose"
msgstr ""

#: ../nodes/3D Processing/box_vol_est_overview.rst:20
msgid ""
"Choose Centroid Pose: If selected, the pose's position for each box will "
"be based on the weighted center of the point cloud, as opposed to the "
"center of the box."
msgstr ""

#: ../nodes/3D Processing/box_vol_est_overview.rst:21
msgid ""
"Correct Pose Rotation: Selecting this will rotate each pose such that the"
" amount of rotation from the identity pose doesn't deviate past pi/2. In "
"other words, the red arrow of each pose always has a positive "
"x-component."
msgstr ""

#: ../nodes/3D Processing/box_vol_est_overview.rst:22
msgid ""
"Downsample Strength: Downsamples each cloud by creating a voxel grid and "
"averaging all points in each voxel into a single point. In basic "
"operation, this is a value from 0-100. In advanced operation, you can "
"specify the dimensions of the voxels. Higher downsampling leads to faster"
" operation, at the potential cost of worse results."
msgstr ""

#: ../nodes/3D Processing/box_vol_est_overview.rst:23
msgid ""
"Lock Z axis: if selected, the z axis of every picking pose will have the "
"same direction as the z axis of reference pose."
msgstr ""

#: ../nodes/3D Processing/box_vol_est_procedure.rst:2
msgid "Procedure in Using Box Volume Estimation Node"
msgstr ""

#: ../nodes/3D Processing/box_vol_est_procedure.rst:4
msgid "Pre-process scene cloud, define reference frame"
msgstr ""

#: ../nodes/3D Processing/box_vol_est_procedure.rst:5
msgid ""
"Do point cloud segmentation using DL segmentation node or regular "
"segmentation node"
msgstr ""

#: ../nodes/3D Processing/box_vol_est_procedure.rst:6
msgid ""
"Use scene crop to separate scene cloud into a vector of point clouds "
"using segmentation result. Each segment will contain a box"
msgstr ""

#: ../nodes/3D Processing/box_vol_est_procedure.rst:7
msgid "Run box volume estimation node on segmented point clouds."
msgstr ""

#: ../nodes/3D Processing/box_vol_est_procedure.rst:8
msgid ""
"Use pick adjustment node to further process picking pose based on pose "
"and volume (width and height) of the box"
msgstr ""

#: ../nodes/3D Processing/box_vol_est_procedure.rst:11
msgid "Pre-process Scene cloud"
msgstr ""

#: ../nodes/3D Processing/box_vol_est_procedure.rst:13
msgid ""
"In order to better estimate the width and height of the boxes, the point "
"cloud must be pre-processed"
msgstr ""

#: ../nodes/3D Processing/box_vol_est_procedure.rst:15
msgid "Use adjust bounding box to filter out the noises in the point cloud."
msgstr ""

#: ../nodes/3D Processing/box_vol_est_procedure.rst:16
msgid ""
"Use set reference frame to define the reference frame. In ring "
"interactor, try to align the x-y plane (purple ring) with the box surface"
msgstr ""

#: ../nodes/3D Processing/box_vol_est_procedure.rst:17
msgid "Use normals operation to compute the normal of the point cloud."
msgstr ""

#: ../nodes/3D Processing/box_vol_est_procedure.rst:26
msgid "Tuning Parameters to Get Best Estimation"
msgstr ""

#: ../nodes/3D Processing/box_vol_est_procedure.rst:28
msgid ""
"Use \"Lock Z Axes\" option so that the z axes of the poses will always be"
" perpendicular to the reference plane"
msgstr ""

#: ../nodes/3D Processing/box_vol_est_procedure.rst:29
msgid ""
"Use \"Use OBB\" to estimate the rotated box. Use \"Use 2D Correction\" to"
" better estimate the 2d rotation of the box"
msgstr ""

#: ../nodes/3D Processing/cloud_process.rst:2
msgid "Cloud Process Node"
msgstr ""

#: ../nodes/3D Processing/cloud_process.rst:5
msgid ""
"Cloud process node is a utility node that performs arbitrary number of "
"operations on the input point cloud."
msgstr ""

#: ../nodes/3D Processing/cloud_process_operation.rst:2
msgid "Operations and Parameters"
msgstr ""

#: ../nodes/3D Processing/cloud_process_operation.rst:4
msgid ""
"This node supports a variety of operations. Each of them has unique "
"parameters."
msgstr ""

#: ../nodes/3D Processing/cloud_process_operation.rst:7
msgid "Downsample"
msgstr ""

#: ../nodes/3D Processing/cloud_process_operation.rst:9
msgid ""
"This operation takes in 3 spatial resolutions (x, y, z). We use this "
"resolution to define a voxel grid size from which to subsample the "
"points. The output of this operation will be a new cloud that is "
"subsampled to contain fewer points than the original. Note this does not "
"maintain the organized structure of the output cloud (output only "
"contains a height of 1)."
msgstr ""

#: ../nodes/3D Processing/cloud_process_operation.rst:17
msgid "Outlier Removal"
msgstr ""

#: ../nodes/3D Processing/cloud_process_operation.rst:18
msgid ""
"This operation is similar to downsample. It reduces the number of points "
"in the cloud; however, it uses the mean and variance of the distance "
"between points. Based on the input values (k and cutoff) it calculates "
"the mean and variance in the distance of the given point from its K "
"immediate neighbors. For all points whose mean distances are outside an "
"interval defined by the global distances mean and standard deviation can "
"be considered as outliers and trimmed from the dataset. Specifically, we "
"calculate the following to determine if the point is an outlier or not."
msgstr ""

#: ../nodes/3D Processing/cloud_process_operation.rst:27
msgid "Crop a Region"
msgstr ""

#: ../nodes/3D Processing/cloud_process_operation.rst:29
msgid ""
"This operation takes in a field name (“x” “y“ or “z”) and the bounds for "
"that region. The output of this operation will return a cloud with that "
"specific region cropped."
msgstr ""

#: ../nodes/3D Processing/cloud_process_operation.rst:35
msgid "Normals"
msgstr ""

#: ../nodes/3D Processing/cloud_process_operation.rst:37
msgid ""
"With the Normals operation, we estimate the surface normal of each region"
" in the point cloud. The operation takes in three values(depth factor, "
"normal smoothness, and k neighbors). Most of the time there is no need to"
" modify any of the default values. This operation has no visual effect."
msgstr ""

#: ../nodes/3D Processing/cloud_process_operation.rst:41
msgid ""
"Normal Depth Factor: The depth change threshold for computing object "
"borders"
msgstr ""

#: ../nodes/3D Processing/cloud_process_operation.rst:42
msgid ""
"Normal Smoothness: The factor which influences the size of the area used "
"to smooth normals"
msgstr ""

#: ../nodes/3D Processing/cloud_process_operation.rst:43
msgid ""
"Normal K Neighbors: This input is only required if the input cloud is "
"unorganized and, combined with the normal smoothness value, defines the "
"search region."
msgstr ""

#: ../nodes/3D Processing/cloud_process_operation.rst:45
msgid "The computed normal data will be stored with the point cloud object."
msgstr ""

#: ../nodes/3D Processing/cloud_process_operation.rst:48
msgid "Transform Coordinates"
msgstr ""

#: ../nodes/3D Processing/cloud_process_operation.rst:50
msgid ""
"This applies a 3D affine transform to the input point cloud and returns "
"the transformed version of the cloud."
msgstr ""

#: ../nodes/3D Processing/cloud_process_operation.rst:56
msgid "Set Reference Frame"
msgstr ""

#: ../nodes/3D Processing/cloud_process_operation.rst:58
msgid "Define a reference coordinate using the interactor."
msgstr ""

#: ../nodes/3D Processing/cloud_process_operation.rst:65
msgid "Dynamic Box Filter"
msgstr ""

#: ../nodes/3D Processing/cloud_process_operation.rst:67
msgid ""
"This operation crops the z region of the cloud by finding the point that "
"is highest and cropping everything below a certain threshold. This "
"operation is usually used when the users want to keep point cloud within "
"a certain range in depth (e.g. the top layer of a pile of boxes)."
msgstr ""

#: ../nodes/3D Processing/cloud_process_operation.rst:70
msgid ""
"Please note that this filter is based on the reference coordinate defined"
" in the previous operation. Before using this operation, use set "
"reference frame operation to set the reference coordinate."
msgstr ""

#: ../nodes/3D Processing/cloud_process_operation.rst:73
msgid ""
"The filtering process starts from the origin of the reference coordinate."
" It divides point cloud into partitions along z- direction. The starting "
"partition is the first partition with points more than *Points Threshold*"
" (user-defined parameter). Then the filter will keep points withing the "
"following *Distance Threshold* mm."
msgstr ""

#: ../nodes/3D Processing/cloud_process_operation.rst:79
msgid ""
"Threshold: range in millimeter along z axis, the points in range will be "
"kept"
msgstr ""

#: ../nodes/3D Processing/cloud_process_operation.rst:80
msgid ""
"Points Threshold: number of points a segmentation along z axis must have "
"to be considered a staring point of filtering, this determines the top of"
" the dynamic box."
msgstr ""

#: ../nodes/3D Processing/cloud_process_operation.rst:83
msgid "Adjust Bounding Box"
msgstr ""

#: ../nodes/3D Processing/cloud_process_operation.rst:88
msgid ""
"This operation crops the cloud by placing a bounding box that the you can"
" adjust by clicking on the adjust box option. Once the you set the "
"bounding box the first time it will remember this choice so that you do "
"not have to reconfigure the box again. You can uncheck the Adjust box "
"option so that they do not have to interact with the box once the "
"adjustments are finished."
msgstr ""

#: ../nodes/3D Processing/cloud_process_operation.rst:92
msgid ""
"To enable the Adjust Bounding Box function, make sure to check the Adjust"
" Box before running."
msgstr ""

#: ../nodes/3D Processing/cloud_process_operation.rst:94
msgid ""
"When the Adjust Box is checked, a bounding box will display in the scene "
"every time the Cloud Process Node is being run. To adjust the bounding "
"box:"
msgstr ""

#: ../nodes/3D Processing/cloud_process_operation.rst:96
msgid "Mouse left key on the box surface to rotate the box"
msgstr ""

#: ../nodes/3D Processing/cloud_process_operation.rst:97
msgid "Mouse right(press down) key on the box to move around the whole box"
msgstr ""

#: ../nodes/3D Processing/cloud_process_operation.rst:98
msgid "Mouse left key outside the box to rotate the scene"
msgstr ""

#: ../nodes/3D Processing/cloud_process_operation.rst:99
msgid "Mouse left(press down) key outside the box to move the whole scene"
msgstr ""

#: ../nodes/3D Processing/cloud_process_operation.rst:100
msgid "Mouse mid(roll) key to zoom in/out the scene"
msgstr ""

#: ../nodes/3D Processing/cloud_process_operation.rst:101
msgid "Drag on the sliding box to adjust box's rotation around x,y,z axis"
msgstr ""

#: ../nodes/3D Processing/cloud_process_operation.rst:102
msgid "Press 0 or Exist Interactor button to confirm change"
msgstr ""

#: ../nodes/3D Processing/cloud_process_operation.rst:104
msgid ""
"When the Adjust Box is unchecked, the bounding box will the the same as "
"last time when you defined a box, or the default one if it's never "
"defined."
msgstr ""

#: ../nodes/3D Processing/cloud_process_operation.rst:106
msgid ""
"Also, the width of the bounding box can be detected using QR-Code. If the"
" object in the scene is marked by QR markers, the initial width and depth"
" of the bounding box will be determined by 3 QR markers."
msgstr ""

#: ../nodes/3D Processing/cloud_process_operation.rst:113
msgid "Color Filter"
msgstr ""

#: ../nodes/3D Processing/cloud_process_operation.rst:115
msgid ""
"The Color Filter Operation can filter out or keep the color that is "
"selected from the scene."
msgstr ""

#: ../nodes/3D Processing/cloud_process_operation.rst:117
msgid ""
"The step of picking a color and define a threshold are: 1. Define if you "
"want to keep(Include) or remove(Exclude) the points with the color you "
"select. 2. Input the RGB value or click the Pick Color button to pick a "
"color from the screen. 3. Set the Color Threshold. If the RGB value of a "
"point in the scene falls inside the range of Color Spec +/- Threshold * "
"10. This point will be Exclude/Include in the scene."
msgstr ""

#: ../nodes/3D Processing/cloud_process_operation.rst:127
msgid "Merge Point Clouds"
msgstr ""

#: ../nodes/3D Processing/cloud_process_operation.rst:129
msgid ""
"This operation takes in another point cloud as an input and merge these "
"two point clouds. You are also able to define the pose of the second "
"point cloud. The below image shows merging two point clouds with the "
"second one being translated along z axis."
msgstr ""

#: ../nodes/3D Processing/cloud_process_operation.rst:136
msgid "Depth Inpainting & Smoothing"
msgstr ""

#: ../nodes/3D Processing/cloud_process_operation.rst:138
msgid ""
"Apply smoothing to and inpaint the depth image of the input point cloud. "
"This operation helps to reduce the noise in the point cloud"
msgstr ""

#: ../nodes/3D Processing/cloud_process_operation.rst:141
msgid "Depth Diff"
msgstr ""

#: ../nodes/3D Processing/cloud_process_operation.rst:143
msgid "Subtract points from the input cloud using cloud b."
msgstr ""

#: ../nodes/3D Processing/cloud_process_operation.rst:145
msgid ""
"Cloud b The cloud we are subtracting from the input. Result is input "
"cloud - cloud_b."
msgstr ""

#: ../nodes/3D Processing/cloud_process_operation.rst:146
msgid ""
"Distance Threshold: The allowable depth difference between corresponding "
"points for them to be considered to have the same value. Larger values "
"remove more points."
msgstr ""

#: ../nodes/3D Processing/cloud_process_operation.rst:149
msgid "Apply Mask"
msgstr ""

#: ../nodes/3D Processing/cloud_process_operation.rst:151
msgid "Apply a 2d mask to the point cloud."
msgstr ""

#: ../nodes/3D Processing/cloud_process_operation.rst:153
msgid ""
"Mask: Mask Image, the point cloud has to be organized and the mask image "
"must have the same width and depth with the point cloud"
msgstr ""

#: ../nodes/3D Processing/cloud_process_operation.rst:156
msgid "RGB Restore Mode"
msgstr ""

#: ../nodes/3D Processing/cloud_process_operation.rst:158
msgid ""
"Sometimes during the cloud process the rgb information of some points "
"inside the region of interest are lost, because the corresponding clouds "
"are noise. This mode restores some of the rgb information using the "
"average of neighboring points."
msgstr ""

#: ../nodes/3D Processing/cloud_process_operation.rst:161
msgid ""
"Mode: box mode, where the rgb is the average of points in a square "
"kernel; or tight mode, where the rgb is the average of neighboring valid "
"points."
msgstr ""

#: ../nodes/3D Processing/cloud_process_operation.rst:162
msgid "Iteration: number of times the rgb restore operation is applied."
msgstr ""

#: ../nodes/3D Processing/cloud_process_operation.rst:163
msgid ""
"Dilation size: size of dilation kernel, bigger the number, more rgb "
"information maybe restored."
msgstr ""

#: ../nodes/3D Processing/cloud_process_operation.rst:164
msgid ""
"Erosion size: size of erosion kernel, bigger the number, more rgb "
"information maybe restored."
msgstr ""

#: ../nodes/3D Processing/cloud_process_overview.rst:7
msgid "Point Cloud: the input point cloud to be processed."
msgstr ""

#: ../nodes/3D Processing/cloud_process_overview.rst:12
msgid ""
"outputCloud: the output point cloud after processing. depthMap: the depth"
" image of the processed point cloud image: the rgp image of the processed"
" point cloud referenceFrame: the reference coordinate defined in 3d "
"process node, used as input of other nodes mergePoses: transformation "
"applied to the second point cloud, when merging two point cloud"
msgstr ""

#: ../nodes/3D Processing/cloud_to_depth_conversion.rst:2
msgid "Cloud To Depth Conversion Node"
msgstr ""

#: ../nodes/3D Processing/cloud_to_depth_conversion.rst:4
msgid ""
"This node converts a point cloud to a depth image, or a depth image back "
"to point cloud."
msgstr ""

#: ../nodes/3D Processing/dl_classify.rst:2
msgid "Deep Learning Classification Node"
msgstr ""

#: ../nodes/3D Processing/dl_classify.rst:4
msgid ""
"The DL Classification Node offers state-of-the-art classification of "
"point clouds using pre-trained models. The setup of this node is very "
"similar to DL Segmentation with the only difference being the task at "
"hand."
msgstr ""

#: ../nodes/3D Processing/dl_classify_overview.rst:8
msgid "Cloud Ptr: point cloud used for classification"
msgstr ""

#: ../nodes/3D Processing/dl_classify_overview.rst:9
msgid "Image Input: RGB image used for classification"
msgstr ""

#: ../nodes/3D Processing/dl_classify_overview.rst:14
msgid "classLabel: label of the object, an int defined by the deep learning model"
msgstr ""

#: ../nodes/3D Processing/dl_classify_overview.rst:15
msgid "confidence: confidence of the classification"
msgstr ""

#: ../nodes/3D Processing/dl_classify_overview.rst:18
msgid "Classification Setting"
msgstr ""

#: ../nodes/3D Processing/dl_classify_overview.rst:20
msgid ""
"Model Mode: use only RGB for classification; use only depth(from point "
"cloud) for classification; or use both."
msgstr ""

#: ../nodes/3D Processing/dl_classify_overview.rst:21
#: Processing/dl_segment_overview.rst:30
msgid "Model File Path: path to deep learning model"
msgstr ""

#: ../nodes/3D Processing/dl_classify_overview.rst:22
#: Processing/dl_segment_overview.rst:31
msgid "Config File Path: path to deep learning config file"
msgstr ""

#: ../nodes/3D Processing/dl_classify_procedure.rst:2
msgid "Procedure in Using DL Classification Node"
msgstr ""

#: ../nodes/3D Processing/dl_classify_procedure.rst:4
msgid ""
"DL classification can be performed on any point cloud or image. However "
"in most cases there will be multiple objects in the scene with different "
"classes, so it is better to separate out each objects. This can be "
"completed using DL segmentation node."
msgstr ""

#: ../nodes/3D Processing/dl_classify_procedure.rst:7
msgid "The steps to use DL classification node:"
msgstr ""

#: ../nodes/3D Processing/dl_classify_procedure.rst:9
msgid ""
"Separate out each objects in point cloud or image. The purpose of this "
"step is to obtain point clouds or image, each containing an object to "
"classify"
msgstr ""

#: ../nodes/3D Processing/dl_classify_procedure.rst:10
msgid ""
"For each object in 1. Use DL classification to determine the type of the "
"object"
msgstr ""

#: ../nodes/3D Processing/dl_classify_procedure.rst:11
msgid "Based on object label output, do different actions"
msgstr ""

#: ../nodes/3D Processing/dl_segment.rst:2
msgid "Deep Learning Segmentation Node"
msgstr ""

#: ../nodes/3D Processing/dl_segment.rst:4
msgid ""
"The DL Segmentation Node offers state-of-the-art segmentation of point "
"clouds using pre-trained models. The Node can be used anywhere that "
"normal segmentation is used and offers the same functionality with less "
"configuration."
msgstr ""

#: ../nodes/3D Processing/dl_segment_overview.rst:7
msgid "Cloud Ptr: point cloud used for segmentation"
msgstr ""

#: ../nodes/3D Processing/dl_segment_overview.rst:8
msgid "Image Input: RGB image used for segmentation"
msgstr ""

#: ../nodes/3D Processing/dl_segment_overview.rst:12
msgid ""
"bboxResults: a vector of bounding boxes of the segments. Each element "
"contains top-left, bottom-right coordinate of each box."
msgstr ""

#: ../nodes/3D Processing/dl_segment_overview.rst:13
msgid "numDetected: number of segments detected."
msgstr ""

#: ../nodes/3D Processing/dl_segment_overview.rst:22
msgid "segmResults: a vector of segmentation results, for each segment."
msgstr ""

#: ../nodes/3D Processing/dl_segment_overview.rst:15
msgid "center_pt: 2d point coordinate of the center."
msgstr ""

#: ../nodes/3D Processing/dl_segment_overview.rst:16
msgid "centroid_3d: 3d point coordinate of the center."
msgstr ""

#: ../nodes/3D Processing/dl_segment_overview.rst:17
msgid "depth: depth image."
msgstr ""

#: ../nodes/3D Processing/dl_segment_overview.rst:18
msgid "eigen_vecs: eigen vectors representing trends of the variance."
msgstr ""

#: ../nodes/3D Processing/dl_segment_overview.rst:19
msgid "label: label of the segment."
msgstr ""

#: ../nodes/3D Processing/dl_segment_overview.rst:20
msgid "mask: mask of the segment, the mask has the size of the original image."
msgstr ""

#: ../nodes/3D Processing/dl_segment_overview.rst:21
msgid "num_points: number of points in the segment."
msgstr ""

#: ../nodes/3D Processing/dl_segment_overview.rst:22
msgid "pca: image representing PCA of the segment."
msgstr ""

#: ../nodes/3D Processing/dl_segment_overview.rst:23
msgid "rgb: rgb image of the segment."
msgstr ""

#: ../nodes/3D Processing/dl_segment_overview.rst:24
msgid "success: whether segmentation is successful(finds at least one segment)."
msgstr ""

#: ../nodes/3D Processing/dl_segment_overview.rst:27
msgid "Deep Learning Parameters"
msgstr ""

#: ../nodes/3D Processing/dl_segment_overview.rst:29
msgid ""
"Model Mode: use only RGB for classification; use only depth(from point "
"cloud) for classification; or use both"
msgstr ""

#: ../nodes/3D Processing/dl_segment_overview.rst:32
msgid "Model Weights Path: path to model weights file"
msgstr ""

#: ../nodes/3D Processing/dl_segment_overview.rst:33
msgid ""
"Model Prediction Type: defines if the model is being used for "
"segmentation of just the object (Detectron2 models) or if we are "
"segmenting the picking positions (UNet)."
msgstr ""

#: ../nodes/3D Processing/dl_segment_overview.rst:34
msgid ""
"Model Sort Type: method to sort segmentation results, can be one of IOU "
"Occluded, Binary Occluded, Area."
msgstr ""

#: ../nodes/3D Processing/dl_segment_overview.rst:35
msgid "Show Label: whether to display label of each segment."
msgstr ""

#: ../nodes/3D Processing/dl_segment_overview.rst:41
msgid "Post processing:"
msgstr ""

#: ../nodes/3D Processing/dl_segment_overview.rst:37
msgid ""
"min/max area: values in the range [0,1] which represent the percentage of"
" the image and segment can occupy."
msgstr ""

#: ../nodes/3D Processing/dl_segment_overview.rst:38
msgid ""
"min/max eigenval: Similar to how the segmentation calculates the PCA of "
"each segment we calculate that here and limit the eigen values. Eigen "
"value 1 is the longer axis."
msgstr ""

#: ../nodes/3D Processing/dl_segment_overview.rst:39
msgid "min confidence: minimum confidence required for each segment."
msgstr ""

#: ../nodes/3D Processing/dl_segment_overview.rst:40
msgid ""
"NMS threshold: threshold for applying soft NMS to the bounding boxes. "
"This removes boxes that are too close together. Default value is 0.8, "
"range is [0,1]."
msgstr ""

#: ../nodes/3D Processing/dl_segment_overview.rst:41
msgid ""
"Erosion/Dilation sizes: the kernel size used for erosion/dilation applied"
" to segmentation mask and segmentation RGB image."
msgstr ""

#: ../nodes/3D Processing/dl_segment_overview.rst:42
msgid ""
"Erosion/Dilation iteration: number of times erosion/dilation is applied "
"to segmentation mask and segmentation RGB image."
msgstr ""

#: ../nodes/3D Processing/dl_segment_procedure.rst:2
msgid "Procedure of Using DL Segmentation Node"
msgstr ""

#: ../nodes/3D Processing/dl_segment_procedure.rst:4
msgid ""
"DL segmentation can be performed on one of point cloud, image, or both. "
"Note that DL segmentation works best when the input contains background "
"information around the object. In pre-processing, avoid using filters "
"like color filter that may remove the background and only keep the "
"object."
msgstr ""

#: ../nodes/3D Processing/dl_segment_procedure.rst:8
#: Processing/segmentation_procedure.rst:7
msgid "Steps in using DL segmentation node"
msgstr ""

#: ../nodes/3D Processing/dl_segment_procedure.rst:10
#: Processing/segmentation_procedure.rst:9
msgid ""
"Pre-process the scene with ROI or adjust bounding box operation. This "
"will improve search efficiency"
msgstr ""

#: ../nodes/3D Processing/dl_segment_procedure.rst:11
#: Processing/segmentation_procedure.rst:10
msgid "Run DL segmentation to find object segments from the scene"
msgstr ""

#: ../nodes/3D Processing/dl_segment_procedure.rst:12
#: Processing/segmentation_procedure.rst:11
msgid "(Optional) Post-process the segment masks"
msgstr ""

#: ../nodes/3D Processing/dl_segment_procedure.rst:14
#: Processing/segmentation_procedure.rst:13
msgid "After segmentation, you can use the result in following ways."
msgstr ""

#: ../nodes/3D Processing/dl_segment_procedure.rst:16
#: Processing/segmentation_procedure.rst:15
msgid ""
"Use center point of the segments as the 2D positions of object. Estimate "
"3d positions using reconstruct node. Use these 2D poses or 3D poses to "
"determine picking positions"
msgstr ""

#: ../nodes/3D Processing/dl_segment_procedure.rst:17
#: Processing/segmentation_procedure.rst:16
msgid ""
"Use scene crop to divide a scene point cloud into a vector of point "
"clouds, each contains point cloud of one object"
msgstr ""

#: ../nodes/3D Processing/dl_segment_procedure.rst:18
#: Processing/segmentation_procedure.rst:17
msgid "More."
msgstr ""

#: ../nodes/3D Processing/dl_segment_procedure.rst:21
msgid "Adjusting Segment Mask Size With Post-processing"
msgstr ""

#: ../nodes/3D Processing/dl_segment_procedure.rst:23
msgid ""
"The initial result of the DL segmentation node may not contain all the "
"points of the object because many deep learning model use dowmsampling "
"for prediction. You can adjust the size of the segment based on your need"
" (to reduce possible noise or to include as much object information as "
"possible) using erosion and dilation post-processing option."
msgstr ""

#: ../nodes/3D Processing/dl_segment_procedure.rst:27
msgid ""
"Below image shows the result of erosion, the result mask is smaller than "
"the actual object"
msgstr ""

#: ../nodes/3D ../nodes/Robot/index.rst:4 ../nodes/Utility/index.rst:6
#: ../nodes/index.rst:6 Processing/index.rst:4
msgid "Contents"
msgstr ""

#: ../nodes/3D Processing/index.rst:2
msgid "3D Processing Nodes"
msgstr ""

#: ../nodes/3D Processing/mesh_process.rst:2
msgid "Mesh Process Node"
msgstr ""

#: ../nodes/3D Processing/mesh_process.rst:4
msgid ""
"Often, polygon meshes contain sparse points, relying more on polygons to "
"represent surfaces. The Mesh Process Node processes an input polygon mesh"
" and generates a point cloud that can be used for finding model features."
msgstr ""

#: ../nodes/3D Processing/mesh_process.rst:9
msgid ""
"Two process types are available: * Generate Cloud: Generates a dense "
"cloud of the mesh's surface * Generate Edge: Generates a point cloud with"
" the mesh's edges"
msgstr ""

#: ../nodes/3D Processing/mesh_process.rst:23
msgid "Model Mesh: A polygon mesh"
msgstr ""

#: ../nodes/3D Processing/mesh_process.rst:28
msgid "cloud: point cloud or edge cloud converted from polygon mesh"
msgstr ""

#: ../nodes/3D Processing/mesh_process.rst:29
msgid "mass center: mass center of the result point cloud"
msgstr ""

#: ../nodes/3D Processing/pallet_loading.rst:2
msgid "Pallet Loading Node"
msgstr ""

#: ../nodes/3D Processing/pallet_loading.rst:5
msgid ""
"The purpose of the pallet loading node is to take the 'Dimensions' output"
" from the Box Volume Estimation node and systematically generate poses "
"for each box in order to load them onto a pallet. There are many "
"different loading algorithms for the you to choose from: Shelf, "
"Guillotine, Max Rects, and Skyline packing, each with their own "
"heuristics. Boxes will be loaded one at a time onto the pallet layer by "
"layer. Boxes can be placed slightly outside the bounds of the pallet, "
"based on the level of tolerance specified by the user. Once a layer is "
"deemed to be full, poses will be generated for the next layer. In order "
"to prevent boxes being stacked over empty space (or mostly empty space), "
"any empty space near the edges of the pallet will be ignored on "
"subsequent layers. As an example, let's say that we have a pallet with "
"dimensions 500x500, and that the pallet has been filled such that the "
"boxes are arranged in a gapless rectangle with dimensions 490x470. Since "
"the layer has been determined to be full, we don't want boxes to be "
"placed over the empty space near the edges. Therefore, the next layer "
"will be loaded under the dimensions of 490x470, plus tolerance. You has "
"complete control of the size and height of the pallet."
msgstr ""

#: ../nodes/3D Processing/pallet_loading.rst:13
msgid ""
"While a layer is being filled, the maximum height of the boxes in the "
"current layer is kept track of. Once a layer is filled, this maximum "
"height becomes the new “ground” for the next layer. Therefore, for "
"obvious reasons, it is best to use boxes of similar height when using "
"this node."
msgstr ""

#: ../nodes/3D Processing/pallet_loading.rst:16
msgid ""
"Once the config page has been set and boxes have been loaded onto the "
"pallet, you cannot go back and change the config settings until the "
"pallet has been cleared. Users can do so by clicking the 'Reset Pallet' "
"button. Additionally, there is automated control modes where you can "
"choose to remove the most recent box from the pallet (e.g. if the robot "
"gripper dropped or misplaced the last box) before placing the next one, "
"or to automatically clear the pallet before loading the next box."
msgstr ""

#: ../nodes/3D Processing/pallet_loading.rst:19
msgid ""
"Users also have the option of electing to manually determine the "
"dimensions of the next box, instead of using the 'Dimensions' output from"
" a Box Volume Estimation node."
msgstr ""

#: ../nodes/3D Processing/pallet_loading.rst:27
msgid ""
"Box volume: a vector of box volumes from the output of box volume "
"estimation node"
msgstr ""

#: ../nodes/3D Processing/pallet_loading.rst:31
msgid "Stored Poses: a vector of poses representing the placement of each box."
msgstr ""

#: ../nodes/3D Processing/pallet_loading.rst:38
msgid ""
"Run Type: Integer that gives the node instructions on what to do with the"
" current saved pallet before attempting to add the current box. Can only "
"be set in the GUI by linking an output from another node or by linking "
"some variable. The three accepted integers are as follows:"
msgstr ""

#: ../nodes/3D Processing/pallet_loading.rst:37
msgid "REGULAR (0): Do not modify the current pallet"
msgstr ""

#: ../nodes/3D Processing/pallet_loading.rst:38
msgid ""
"RESTART (1): Delete the current pallet and load the current box onto an "
"empty pallet"
msgstr ""

#: ../nodes/3D Processing/pallet_loading.rst:39
msgid "REDO (2): Delete the previously added box from the pallet."
msgstr ""

#: ../nodes/3D Processing/pallet_loading.rst:40
msgid "Pallet X: Width of the pallet, in mm."
msgstr ""

#: ../nodes/3D Processing/pallet_loading.rst:41
msgid "Pallet Y: Length of the pallet, in mm."
msgstr ""

#: ../nodes/3D Processing/pallet_loading.rst:42
msgid ""
"Pallet Height: Maximum height that objects can be stacked to before "
"determining the entire pallet to be full."
msgstr ""

#: ../nodes/3D Processing/pallet_loading.rst:76
msgid ""
"Bin Packing Algorithm: Determines how the boxes are fit together on the "
"pallet."
msgstr ""

#: ../nodes/3D Processing/pallet_loading.rst:51
msgid ""
"Shelf: Has the following heuristic choices for choosing an ideal location"
" for each incoming box:"
msgstr ""

#: ../nodes/3D Processing/pallet_loading.rst:45
msgid ""
"Shelf Next Fit: Create a new shelf if the box cannot fit in the current "
"shelf"
msgstr ""

#: ../nodes/3D Processing/pallet_loading.rst:46
msgid "Shelf First Fit: Place box in first shelf it can fit"
msgstr ""

#: ../nodes/3D Processing/pallet_loading.rst:47
msgid "Shelf Best Area Fit: Place box as to maximize total used shelf area"
msgstr ""

#: ../nodes/3D Processing/pallet_loading.rst:48
msgid "Shelf Worst Area Fit: Place box as to maximize total available shelf area"
msgstr ""

#: ../nodes/3D Processing/pallet_loading.rst:49
msgid "Shelf Best Height Fit: Place box as to minimize leftover height"
msgstr ""

#: ../nodes/3D Processing/pallet_loading.rst:50
msgid ""
"Shelf Best Width Fit: Place rectangle such that remaining width of shelf "
"space is minimized"
msgstr ""

#: ../nodes/3D Processing/pallet_loading.rst:51
msgid "Shelf Worst Width Fit: Place rectangle as to minimize used shelf space"
msgstr ""

#: ../nodes/3D Processing/pallet_loading.rst:52
#: Processing/pallet_loading.rst:77
msgid ""
"Use Waste Map: Should the algorithm keep track of wasted space, and place"
" boxes into that space if they fit?"
msgstr ""

#: ../nodes/3D Processing/pallet_loading.rst:65
msgid ""
"Guillotine:Has the following heuristic choices for choosing how to split "
"up remaining free space on the layer:"
msgstr ""

#: ../nodes/3D Processing/pallet_loading.rst:54
msgid ""
"Split Shorter Leftover Axis: Creates free boxes by splitting shorter "
"leftover axis"
msgstr ""

#: ../nodes/3D Processing/pallet_loading.rst:55
msgid ""
"Split Longer Leftover Axis: Creates free boxes by splitting larger "
"leftover axis"
msgstr ""

#: ../nodes/3D Processing/pallet_loading.rst:56
msgid ""
"Split Minimize Area: Creates free boxes by making the difference in areas"
" as large as possible"
msgstr ""

#: ../nodes/3D Processing/pallet_loading.rst:57
msgid ""
"Split Maximize Area: Creates free boxes by making the difference in areas"
" as small as possible"
msgstr ""

#: ../nodes/3D Processing/pallet_loading.rst:58
msgid "Split Shorter Axis: Creates free boxes by splitting shorter overall axis"
msgstr ""

#: ../nodes/3D Processing/pallet_loading.rst:59
msgid "Split Longer Axis: Creates free boxes by splitting longer overall axis"
msgstr ""

#: ../nodes/3D Processing/pallet_loading.rst:60
msgid ""
"Best Area Fit: Pick smallest free rectangle where current rectangle will "
"fit"
msgstr ""

#: ../nodes/3D Processing/pallet_loading.rst:61
msgid ""
"Best Short Side Fit: Pick free rectangle as to minimize length of shorter"
" leftover side"
msgstr ""

#: ../nodes/3D Processing/pallet_loading.rst:62
msgid ""
"Best Long Side Fit: Pick free rectangle as to minimize length of longer "
"leftover side"
msgstr ""

#: ../nodes/3D Processing/pallet_loading.rst:63
msgid ""
"Worst Area Fit: Pick free rectangle as to maximize length of both "
"leftover sides"
msgstr ""

#: ../nodes/3D Processing/pallet_loading.rst:64
msgid ""
"Worst Short Side Fit: Pick free rectangle as to maximize length of "
"shorter leftover side"
msgstr ""

#: ../nodes/3D Processing/pallet_loading.rst:65
msgid ""
"Worst Long Side Fit: Pick free rectangle as to maximize length of longer "
"leftover side"
msgstr ""

#: ../nodes/3D Processing/pallet_loading.rst:66
msgid ""
"Merge: Should the algorithm attempt to combine free rectangles of space "
"and potentially find a better placement?"
msgstr ""

#: ../nodes/3D Processing/pallet_loading.rst:72
msgid ""
"Max Rects: Has the following heuristic choices for choosing where to "
"place each new box."
msgstr ""

#: ../nodes/3D Processing/pallet_loading.rst:68
msgid ""
"Best Short Side Fit: Positions the box against the short side of a free "
"box into which it fits the best"
msgstr ""

#: ../nodes/3D Processing/pallet_loading.rst:69
msgid ""
"Best Long Side Fit: Positions the box against the long side of a free box"
" into which it fits the best."
msgstr ""

#: ../nodes/3D Processing/pallet_loading.rst:70
msgid ""
"Best Area Fit: Positions the box into the smallest free box into which it"
" fits."
msgstr ""

#: ../nodes/3D Processing/pallet_loading.rst:71
msgid "Bottom Left Rule: Does the Tetris placement."
msgstr ""

#: ../nodes/3D Processing/pallet_loading.rst:72
msgid ""
"Contact Point Rule: Chooses the placement where the box touches other "
"boxes as much as possible."
msgstr ""

#: ../nodes/3D Processing/pallet_loading.rst:73
msgid ""
"Allow Flip: Should the algorithm be able to rotate the box when "
"determining how to place it?"
msgstr ""

#: ../nodes/3D Processing/pallet_loading.rst:76
msgid ""
"Skyline: Has the following heuristic choices for choosing where to place "
"each new box:"
msgstr ""

#: ../nodes/3D Processing/pallet_loading.rst:75
msgid ""
"Bottom Left: Places each box as close to the bottom-left corner as "
"possible"
msgstr ""

#: ../nodes/3D Processing/pallet_loading.rst:76
msgid "Min Waste Fit: Places each box as to minimize leftover space"
msgstr ""

#: ../nodes/3D Processing/pallet_loading.rst:78
msgid ""
"Optional Fields: If you elect not to use the 'Dimensions' output from a "
"Box Volume Estimation node, these values will be used instead for the x, "
"y, and z dimensions of the box, respectively. If these values are all 0, "
"the box volume output is used instead."
msgstr ""

#: ../nodes/3D Processing/pallet_loading.rst:79
msgid ""
"Tolerance: Distance, in mm, boxes can be placed such that they may lie "
"slightly outside the bounds of the pallet. Note that this tolerance is "
"applied for the new dimensions on each layer as well. In basic operation "
"mode, this is a single value. In advanced operation mode, users can "
"control the tolerance in both the x and y directions."
msgstr ""

#: ../nodes/3D Processing/pick_adjust.rst:2
msgid "Pick Adjust Node"
msgstr ""

#: ../nodes/3D Processing/pick_adjust.rst:4
msgid ""
"The purpose of the Pick Adjust Node is to alter the poses generated by "
"the Box Volume Estimation Node. These boxes may be picked up by a "
"rectangular vacuum picking plate, which may be significantly larger than "
"the box itself. We want to ensure that the plate can safely pick up the "
"box without interfering with any other boxes nearby (which would be the "
"case in a depalletization scenario)."
msgstr ""

#: ../nodes/3D Processing/pick_adjust.rst:6
msgid ""
"There are two modes for this node: Single-Box picking and Multiple-Box "
"picking. Single-Box is as it sounds - a single new pose will be generated"
" for each existing box. This pose will be translated such that one corner"
" of the plate is flush with one corner of the box, and that no other "
"boxes are covered by the plate.  Multiple-Box picking will generate poses"
" as to minimize the total number of poses generated - i.e., each pose "
"will try and safely cover as many boxes as possible. You can specify the "
"dimensions of the picking plate, in mm."
msgstr ""

#: ../nodes/3D Processing/pick_adjust_overview.rst:7
msgid ""
"Dimensions: a vector of box dimensions from the output of box volume "
"estimation node"
msgstr ""

#: ../nodes/3D Processing/pick_adjust_overview.rst:8
msgid "Original Poses: a vector of poses representing the pick pose of each box"
msgstr ""

#: ../nodes/3D Processing/pick_adjust_overview.rst:9
msgid ""
"Pose Order (optional): a vector representing the order of the original "
"poses from the pick sort node"
msgstr ""

#: ../nodes/3D Processing/pick_adjust_overview.rst:14
msgid "newPoses: valid poses where the vacuum could suck up the original box"
msgstr ""

#: ../nodes/3D Processing/pick_adjust_overview.rst:19
msgid "Plate X: width of the picking plate, default is 300mm"
msgstr ""

#: ../nodes/3D Processing/pick_adjust_overview.rst:20
msgid "Plate Y: height of the picking plate, default is 300mm"
msgstr ""

#: ../nodes/3D Processing/pick_adjust_overview.rst:21
msgid ""
"Threshold low: how much of the box should be covered to be picked up, "
"default is 0.5"
msgstr ""

#: ../nodes/3D Processing/pick_adjust_overview.rst:22
msgid ""
"Threshold high: the upper bound of box coverage to be picked up, default "
"is 1"
msgstr ""

#: ../nodes/3D Processing/pick_adjust_overview.rst:23
msgid ""
"Pre Sort Poses: sort poses in a back-and-force moving pattern, as shown "
"in the below image, the ordering of the pose follows a z-shape pattern."
msgstr ""

#: ../nodes/3D Processing/pick_adjust_procedure.rst:2
msgid "Procedure of Using Pick Adjust Node"
msgstr ""

#: ../nodes/3D Processing/pick_adjust_procedure.rst:4
msgid ""
"Use box volume estimation node to estimate the width and height of the "
"box, and the picking pose of each box."
msgstr ""

#: ../nodes/3D Processing/pick_adjust_procedure.rst:5
msgid "Use pick sort node to determine the picking pose of the vacuum plate"
msgstr ""

#: ../nodes/3D Processing/pick_adjust_procedure.rst:8
msgid "Set Parameters to Get Picking Poses"
msgstr ""

#: ../nodes/3D Processing/pick_adjust_procedure.rst:10
msgid ""
"You can check whether the vacuum position is desired in the display. The "
"green boxes are the boxes to pick and the red rectangles means the "
"picking pose of the vacuum plate. Also each pose is marked with numbers "
"showing the order of the pose."
msgstr ""

#: ../nodes/3D Processing/pick_adjust_procedure.rst:16
msgid "The parameters must be set correctly to get the desired picking pose."
msgstr ""

#: ../nodes/3D Processing/pick_adjust_procedure.rst:18
msgid ""
"Set *plate X* and *plate Y* to be the actual size of the vacuum picking "
"plate"
msgstr ""

#: ../nodes/3D Processing/pick_adjust_procedure.rst:19
msgid ""
"Set *Threshold Low* to be the minimum coverage ratio when vacuum is able "
"to pick up the box"
msgstr ""

#: ../nodes/3D Processing/pick_adjust_procedure.rst:20
msgid ""
"Use default *Threshold High*, unless you want to define a maximum "
"coverage ratio that is lower than 1."
msgstr ""

#: ../nodes/3D Processing/reconstruct.rst:2
msgid "Reconstruct Node"
msgstr ""

#: ../nodes/3D Processing/reconstruct.rst:4
msgid ""
"The Reconstruction Node uses the hypothesis position of a detected object"
" and its centroids to generate a 3D pose. The hypothesis position and "
"centroid information usually comes from the Mode Finder Node. The 3D pose"
" uses the model defined in Mod Finder Node as a reference to compute its "
"translation and rotation(in camera coordinates). In order the visualize "
"the pose, it will be displayed in the scene using a small XYZ axis."
msgstr ""

#: ../nodes/3D Processing/reconstruct_overview.rst:7
msgid "Point Cloud: The captured point cloud of the target scene."
msgstr ""

#: ../nodes/3D Processing/reconstruct_overview.rst:8
msgid "Object Locations: The result from 2D mod_finder/ shape_finder/ dl_segm."
msgstr ""

#: ../nodes/3D Processing/reconstruct_overview.rst:9
msgid "Camera Intrinsic"
msgstr ""

#: ../nodes/3D Processing/reconstruct_overview.rst:10
msgid ""
"Object masks: The masks of the detected model (2D mod_finder) or detected"
" shapes (shape_finder). Not necessary when not using the mask for Z and "
"Rotation computation."
msgstr ""

#: ../nodes/3D Processing/reconstruct_overview.rst:15
msgid "objectPositions: 3d poses computed from the 2d poses"
msgstr ""

#: ../nodes/3D Processing/reconstruct_overview.rst:18
msgid "Estimating Z value"
msgstr ""

#: ../nodes/3D Processing/reconstruct_overview.rst:20
msgid ""
"The node has two ways of constructing z value in 3d poses * Averaging "
"Surrounding Points: This is the default method which uses a set of "
"surrounding points  (square kernel) around the reference point and "
"converts them to a point cloud (using the input point cloud) and takes "
"the average Z value of the corresponding 3D points in the point cloud. "
"The size (radius) of the kernel can also be defined by the user. Using a "
"bigger kernel will result in using more surrounding points for Z "
"computation. * Averaging masking area: This method uses the mask obtained"
" from mod-finder , shape-finder or dl_segm to obtain the Z value by using"
" the non-zero pixels in the mask (model mask, shape mask or segment mask"
"  depending on which node you are using  before reconstruct_node) and "
"taking the average Z value of their corresponding points in the point "
"cloud. There is also a dilation iterations parameter that can be used to "
"dilate the model/shape mask if needed. More dilation results in using "
"more points for Z computation."
msgstr ""

#: ../nodes/3D Processing/reconstruct_overview.rst:25
msgid "Enable Rotation computation"
msgstr ""

#: ../nodes/3D Processing/reconstruct_overview.rst:27
msgid ""
"If this option is checked by the user, the program will compute the "
"rotation of the object with respect to the camera coordinates system. The"
" nodes has two ways of constructing rotation * Surrounding Normal Points:"
" This is the default method which uses a set of surrounding points of the"
" reference point to fit a plane in the point cloud and then, uses this "
"plane to find normal vector which is then used for rotation calculation. "
"However, this method can fail if the surrounding points are nan "
"(invalid), especially in cases that the target shape/ model is a hole. "
"However, you have control in the kernel used around the reference point "
"to fit the plane and calculate the rotation. * Mask Region Normal: This "
"method uses the mask obtained from mod-finder, shape-finder or dl_segm "
"and converts it to a cloud to obtain the Rotation value by using the non-"
"zero pixels in the mask and fitting a plane to the corresponding 3D "
"points. Then, the normal of the plane estimated which is used for "
"rotation calculation. There is also a dilation iterations that can be "
"used to dilate the model/shape/segment mask if needed. More dilation "
"results in using more points for plane fitting and Rotation calculation. "
"This option is especially good for cases that we have detected a "
"shape/model which is actually a hole. In this scenario, most of the "
"cases, the reference point and the surrounding points are nan. Therefore,"
" using the surrounding points is not able to find the normal (unless a "
"big kernel size is used) but using the mask region will use the mask to "
"fit the plane and ignore the nan points."
msgstr ""

#: ../nodes/3D Processing/reconstruct_procedure.rst:2
msgid "Procedure of Using Reconstruct Node"
msgstr ""

#: ../nodes/3D Processing/reconstruct_procedure.rst:4
msgid ""
"Use DL Segmentation, Mod Finder (2D mode), Shape Finder to get a vector "
"of 2D poses."
msgstr ""

#: ../nodes/3D Processing/reconstruct_procedure.rst:5
msgid "Use Reconstruct Node to estimate 3d poses based on the 2d poses."
msgstr ""

#: ../nodes/3D Processing/reconstruct_procedure.rst:11
msgid "Parameter Tunning in Z Computation"
msgstr ""

#: ../nodes/3D Processing/reconstruct_procedure.rst:13
msgid ""
"There are two ways to estimate Z value of the 3d poses: use the average "
"depth of points in a kernel or use average depth of points of represented"
" by a mask. If the poses are from a flat surface object (e.g. a box), it "
"is more efficient to use kernel. Otherwise, using the object mask will "
"take the whole shape information into computation, leading to a better "
"result. Also, if the point cloud has some noisy points around the "
"boundary of the object it is advices to use kernel mode."
msgstr ""

#: ../nodes/3D Processing/reconstruct_procedure.rst:17
msgid ""
"If the point cloud has many invalid points around the center of 2d pose, "
"try to increase the kernel size or dilation iteration to compensate the "
"information lost due to invalid points."
msgstr ""

#: ../nodes/3D Processing/reconstruct_procedure.rst:21
msgid "Parameter Tunning in Rotation Computation"
msgstr ""

#: ../nodes/3D Processing/reconstruct_procedure.rst:23
msgid ""
"You can enable rotation estimation of 3d pose using *Enable Rotation "
"Computation* Flag. Similar to Z Computation, it also has two ways of "
"evaluating rotation. Use the same principle in choosing computation "
"parameters."
msgstr ""

#: ../nodes/3D Processing/scene_crop.rst:2
msgid "Scene Crop Node"
msgstr ""

#: ../nodes/3D Processing/scene_crop.rst:4
msgid ""
"The Scene Crop Node uses segmentation results to crop a Point Cloud and "
"output a vector of clouds corresponding to each segment."
msgstr ""

#: ../nodes/3D Processing/scene_crop_overview.rst:7
msgid ""
"Segment result: segmentation result vector, either from segmentation node"
" or DL segmentation node"
msgstr ""

#: ../nodes/3D Processing/scene_crop_overview.rst:8
msgid "Scene cloud: scene point cloud to be cropped"
msgstr ""

#: ../nodes/3D Processing/scene_crop_overview.rst:13
msgid ""
"segmentClouds: a vector of point cloud, representing the cropped point "
"cloud for each segment"
msgstr ""

#: ../nodes/3D Processing/scene_crop_overview.rst:14
msgid ""
"segmentPoses: poses of each point cloud, if the scene cloud has normals "
"(from cloud process node), this pose will represent the surface normal of"
" the segment"
msgstr ""

#: ../nodes/3D Processing/scene_crop_overview.rst:19
msgid ""
"Use Surface Centroid: whether to compute the centroid of the segmented "
"point cloud when computing segmentPoses"
msgstr ""

#: ../nodes/3D Processing/scene_crop_procedure.rst:2
msgid "Procedure of Using Scene Crop Node"
msgstr ""

#: ../nodes/3D Processing/scene_crop_procedure.rst:4
msgid "Use segmentation node or DL segmentation node to obtain a vector of masks"
msgstr ""

#: ../nodes/3D Processing/scene_crop_procedure.rst:5
msgid ""
"Use scene crop node to crop the scene point cloud into a vector of sub-"
"point clouds, based on the segmentation masks obtained in previous "
"segmentPoses"
msgstr ""

#: ../nodes/3D Processing/scene_crop_procedure.rst:6
msgid ""
"Use a loop sub-flowchart to iterate through each point cloud to process "
"them separately, or feed the whole vector of point clouds into nodes like"
" box volume estimation node to process them as a whole"
msgstr ""

#: ../nodes/3D Processing/segmentation.rst:2
msgid "Segmentation Node"
msgstr ""

#: ../nodes/3D Processing/segmentation.rst:8
msgid ""
"The Segmentation Node clusters the points from an input point cloud into "
"segments. The output segment masks can be used by the Scene Crop Node to "
"create a vector of segment clouds. The matching process will run faster "
"on these segments."
msgstr ""

#: ../nodes/3D Processing/segmentation.rst:11
msgid ""
"RGBD segmentation works best when instances of objects are spaced apart. "
"Otherwise, segments may contain multiple instances of the object. In "
"these cases, normal segmentation may segment out the instances more "
"clearly. Both watershed segmentation are performing on the image using "
"maker generation. They are faster but could result in less accurate "
"segmentation."
msgstr ""

#: ../nodes/3D Processing/segmentation.rst:19
msgid "Four types of Segmentation Nodes are available:"
msgstr ""

#: ../nodes/3D Processing/segmentation.rst:16
msgid ""
"Segmentation RGBD: Uses the RGB and depth information to perform "
"clustering"
msgstr ""

#: ../nodes/3D Processing/segmentation.rst:17
msgid ""
"Segmentation Normal: Uses the normals in the point cloud to perform "
"clustering"
msgstr ""

#: ../nodes/3D Processing/segmentation.rst:18
msgid "RGB only: Performs segmentation on an RGB image."
msgstr ""

#: ../nodes/3D Processing/segmentation.rst:19
msgid "Depth only: Performs segmentation on a Depth image."
msgstr ""

#: ../nodes/3D Processing/segmentation_overview.rst:7
msgid "Cloud Ptr: a point cloud to be segmented"
msgstr ""

#: ../nodes/3D Processing/segmentation_overview.rst:8
msgid "Camera Intrinsic: camera intrinsic parameter used for RGBD segmentation"
msgstr ""

#: ../nodes/3D Processing/segmentation_overview.rst:9
msgid "RGB Pointer: RGB image to be segmented"
msgstr ""

#: ../nodes/3D Processing/segmentation_overview.rst:14
msgid "preSegmRGB: rgb image before segmentation"
msgstr ""

#: ../nodes/3D Processing/segmentation_overview.rst:15
msgid "postSegmDepth: depth image of the scene after segmentation"
msgstr ""

#: ../nodes/3D Processing/segmentation_overview.rst:16
msgid "postSegmPCA: image showing PCA of the scene cluster"
msgstr ""

#: ../nodes/3D Processing/segmentation_overview.rst:17
msgid "postSegmRGB: rgb image after segmentation"
msgstr ""

#: ../nodes/3D Processing/segmentation_overview.rst:18
msgid ""
"results: a vector of segments, each containing a mask image of the size "
"of the scene image, showing which points belong to this segment"
msgstr ""

#: ../nodes/3D Processing/segmentation_overview.rst:24
msgid "Pre-process"
msgstr ""

#: ../nodes/3D Processing/segmentation_overview.rst:26
msgid "Basic Downsample: Level of downsampling when doing segmentation"
msgstr ""

#: ../nodes/3D Processing/segmentation_overview.rst:29
msgid "Segmentation Parameters"
msgstr ""

#: ../nodes/3D Processing/segmentation_overview.rst:31
msgid ""
"Basic Weight Threshold: how much different between the adjacent points to"
" be considered as different segment. Default Value is 50, range is "
"[0,100]."
msgstr ""

#: ../nodes/3D Processing/segmentation_overview.rst:32
msgid ""
"Basic Min Size: minimum size of each segment. Default value is 50, range "
"is [0,100]."
msgstr ""

#: ../nodes/3D Processing/segmentation_overview.rst:35
msgid "Post-processing"
msgstr ""

#: ../nodes/3D Processing/segmentation_overview.rst:37
msgid ""
"Max Segment Size: Maximum size of the segment, segment greater than this "
"will be removed. Default value is 100, range is [0,100]."
msgstr ""

#: ../nodes/3D Processing/segmentation_overview.rst:38
msgid ""
"Min Segment Size: Minimum size of the segment, segment greater than this "
"will be removed. Default value is 0, range is [0,100]."
msgstr ""

#: ../nodes/3D Processing/segmentation_overview.rst:39
msgid ""
"Max Distance to Camera: Maximum distance of points in segment to camera, "
"segment with points further than this distance will be removed. Off by "
"default. Distance unit is millimeter"
msgstr ""

#: ../nodes/3D Processing/segmentation_overview.rst:40
#, python-format
msgid ""
"Use Nan Removal: remove segment with more than 75% of the points invalid,"
" if turned on."
msgstr ""

#: ../nodes/3D Processing/segmentation_procedure.rst:2
msgid "Procedure of Using Segmentation Node"
msgstr ""

#: ../nodes/3D Processing/segmentation_procedure.rst:4
msgid ""
"To get the best segmentation result, is it recommended to use DL "
"segmentation node with pre-trained model. However, it is possible to "
"produce the desired segmentation using segmentation node."
msgstr ""

#: ../nodes/3D Processing/segmentation_procedure.rst:20
msgid "Tunning Segmentation Parameters for Better result"
msgstr ""

#: ../nodes/3D Processing/segmentation_procedure.rst:22
msgid ""
"You can adjust segmentation parameters for better result. To reduce the "
"background effect, increase the *Basic Weight Threshold*. Changing *Basic"
" Min Size* to get the desired segment size."
msgstr ""

#: ../nodes/3D Processing/segmentation_procedure.rst:25
msgid ""
"You can also change segment size by changing *Max Segment Size* and *Min "
"Segment Size* in post-processing."
msgstr ""

#: ../nodes/3D Processing/verification.rst:2
msgid "Verification Node"
msgstr ""

#: ../nodes/3D Processing/verification.rst:7
msgid ""
"Verification checks a matched pose to determine if a model with this pose"
" is well-aligned to the scene cloud, and outputs scores for each pose."
msgstr ""

#: ../nodes/3D Processing/verification.rst:9
msgid "Three methods of verification are available:"
msgstr ""

#: ../nodes/3D Processing/verification.rst:11
msgid ""
"Depth-Mode: Depth-based verification compares the depth difference of "
"points in the scene and in the model at the hypothesis pose. In another "
"word, this mode verifies if the oebject with that pose is 'above' the "
"scene."
msgstr ""

#: ../nodes/3D Processing/verification.rst:13
msgid ""
"Edge-Mode: Edge-based verification compares the outline of the model at "
"the hypothesis pose versus edges extracted from the point cloud."
msgstr ""

#: ../nodes/3D Processing/verification.rst:15
msgid ""
"Stacking-Mode: Stacking Mode is used to determine which object is “on "
"top” when objects are stacked on top of one another. this mode will sort "
"poses according to the visibility."
msgstr ""

#: ../nodes/3D Processing/verification.rst:17
msgid ""
"Edge Mode may fail on objects with curved faces instead of edges where "
"the edges cannot be extracted clearly."
msgstr ""

#: ../nodes/3D Processing/verification.rst:19
msgid ""
"Depth Mode may fail to filter out false positives on very flat objects "
"where the depth difference cannot be distinguished from the background. "
"Decreasing the Accuracy may improve the performance in these cases."
msgstr ""

#: ../nodes/3D Processing/verification.rst:21
msgid ""
"The Confidence is the most important parameter to adjust when configuring"
" this node. By setting this higher, more poses are filtered out based on "
"their verification scores. A recommended step when configuring the "
"detection pipeline is to vary this parameter and compare the remaining "
"poses to find the best value to filter out false positives while keeping "
"true positives."
msgstr ""

#: ../nodes/3D Processing/verification.rst:23
msgid ""
"In Stacking Mode, we calculate the visibility score of each pose then we "
"return the poses sorted by visibility as well as filter poses based on "
"the confidence threshold."
msgstr ""

#: ../nodes/3D Processing/verification.rst:25
msgid ""
"Verification scores are normalized between 0 and 1 and represent the "
"confidence that the pose is correctly aligned to the scene. Poses are "
"also penalized for occlusion, so this process will favor poses that can "
"be picked."
msgstr ""

#: ../nodes/3D Processing/verification_overview.rst:7
msgid "Model Mesh: a point cloud or polygon mesh, representing the model"
msgstr ""

#: ../nodes/3D Processing/verification_overview.rst:8
msgid "Scene Cloud: scene point cloud"
msgstr ""

#: ../nodes/3D Processing/verification_overview.rst:9
msgid "Hypothesis: a vector of poses for each occurrence of model in scene"
msgstr ""

#: ../nodes/3D Processing/verification_overview.rst:14
msgid ""
"poses: a vector valid poses after verification, will be sorted if "
"stacking mode is used"
msgstr ""

#: ../nodes/3D Processing/verification_overview.rst:19
msgid ""
"Confidence: the confidence of a pose to be valid. Default is 50, range is"
" [0,100]"
msgstr ""

#: ../nodes/3D Processing/verification_overview.rst:22
msgid "Depth Mode Parameters"
msgstr ""

#: ../nodes/3D Processing/verification_overview.rst:21
msgid ""
"Occluded Part Tolerance: threshold such that poses with more than this "
"part occluded should be removed. Default is 50, range is [0,100]"
msgstr ""

#: ../nodes/3D Processing/verification_overview.rst:22
msgid ""
"Error Tolerance: how much error points a pose can have. Higher the "
"tolerance, more inaccurate result will be kept. Default is 50, range is "
"[0,100]"
msgstr ""

#: ../nodes/3D Processing/verification_overview.rst:23
msgid ""
"Overlap Ratio: controls the penally low overlap between model and scene. "
"Default is 50, range is [0,100]"
msgstr ""

#: ../nodes/3D Processing/verification_overview.rst:31
msgid "Edge Mode Parameters"
msgstr ""

#: ../nodes/3D Processing/verification_overview.rst:25
msgid ""
"Camera Intrinsic Parameter: camera intrinsic parameter, used for edge "
"extract"
msgstr ""

#: ../nodes/3D Processing/verification_overview.rst:26
msgid "RGB image: RGB image of the scene"
msgstr ""

#: ../nodes/3D Processing/verification_overview.rst:27
msgid ""
"Smoothness: level of smoothness applied to scene edge. Default is 50, "
"range is [0,100]"
msgstr ""

#: ../nodes/3D Processing/verification_overview.rst:28
msgid "Canny Low Factor: lower threshold of canny filter"
msgstr ""

#: ../nodes/3D Processing/verification_overview.rst:29
msgid "Canny High Factor: upper threshold of canny filter"
msgstr ""

#: ../nodes/3D Processing/verification_overview.rst:30
msgid "Angle Threshold: angle threshold for smoothing the extracted edges"
msgstr ""

#: ../nodes/3D Processing/verification_overview.rst:31
msgid ""
"Contrast threshold: threshold for filtering out edges with low difference"
" in depth"
msgstr ""

#: ../nodes/3D Processing/verification_overview.rst:32
msgid "Search Radius: radius used for edge pixel clustering"
msgstr ""

#: ../nodes/3D Processing/verification_overview.rst:34
msgid "Stacking Mode Parameters"
msgstr ""

#: ../nodes/3D Processing/verification_overview.rst:34
msgid ""
"FOV: field of view for viewing camera, greater value means more poses "
"will be seen, and then kept."
msgstr ""

#: ../nodes/3D Processing/verification_procedure.rst:2
msgid "Procedure of Using Verification Node"
msgstr ""

#: ../nodes/3D Processing/verification_procedure.rst:4
msgid ""
"Verification node is usually the final process of 3d object pose "
"estimation. After the poses are verified they can be used to generate "
"picking poses."
msgstr ""

#: ../nodes/3D Processing/verification_procedure.rst:6
msgid ""
"Steps in using verification node: 1. Compute initial 3d poses using 3d "
"object finder node, mod finder node(3d mode), or reconstruct node, etc. "
"2. Use alignment node to refine 3d poses 3. Use verification node to "
"determine which 3d poses are valid"
msgstr ""

#: ../nodes/3D Processing/verification_procedure.rst:12
msgid "Parameter Tunning in Depth Mode"
msgstr ""

#: ../nodes/3D Processing/verification_procedure.rst:14
msgid ""
"Besides verifying if the model is closely aligned with the scene, an "
"important feature of depth mode is to reject poses where objects are "
"below the scene(occluded by other objects). In application this can be "
"used where objects with too much occlusion by other objects can not be "
"picked up. You can change *Occluded Part Tolerance* to determine how much"
" occlusion to reject a pose."
msgstr ""

#: ../nodes/3D Processing/verification_procedure.rst:19
msgid "Parameter Tunning in Edge Mode"
msgstr ""

#: ../nodes/3D Processing/verification_procedure.rst:21
msgid ""
"Normally the edge mode produces lower verification score. Set a lower "
"confidence if you want more poses to be kept. You can also change edge "
"extract parameters and preview them in display."
msgstr ""

#: ../nodes/3D Processing/verification_procedure.rst:25
msgid "Parameter Tunning in Stacking Mode"
msgstr ""

#: ../nodes/3D Processing/verification_procedure.rst:27
msgid ""
"Stacking mode calculates visibility(visible points ratio of the model) by"
" doing a pinhole projection. Changing FOV will change the visibility of "
"the pose, thus change the number of poses being kept."
msgstr ""

#: ../nodes/3D Processing/visualization.rst:2
msgid "Visualization Node"
msgstr ""

#: ../nodes/3D Processing/visualization.rst:4
msgid ""
"Visualization node is a utility node that visualizes point clouds or "
"meshes. It can also apply poses to objects before visualizing. The Node "
"has no output."
msgstr ""

#: ../nodes/3D Processing/visualization.rst:15
msgid "Arbitrary number of visualization items"
msgstr ""

#: ../nodes/3D Processing/visualization.rst:14
msgid "Object: point cloud or mesh, the object to be visualized."
msgstr ""

#: ../nodes/3D Processing/visualization.rst:15
msgid "Pose: optional, a pose to be applied to the object"
msgstr ""

#: ../nodes/Calibration/calibration.rst:6
#: ../nodes/Calibration/calibration_2d.rst:7
#: ../nodes/Calibration/hand_eye_calibration_2d_v02.rst:6
#: ../nodes/Calibration/index.rst:4 ../nodes/Calibration/pose_generation.rst:6
#: ../nodes/Calibration/sphere_calibration.rst:6 ../nodes/Image
#: Processing/index.rst:4
msgid "Content"
msgstr ""

#: ../nodes/Calibration/calibration.rst:2
msgid "Calibration node"
msgstr ""

#: ../nodes/Calibration/calibration.rst:4
msgid ""
"This node performs 3D robot calibration using chessboard or circle grid "
"as the calibration tool. This node can be run in three different modes."
msgstr ""

#: ../nodes/Calibration/calibration_2d.rst:2
msgid "Calibration2D node"
msgstr ""

#: ../nodes/Calibration/calibration_2d.rst:4
msgid ""
"This node performs 2D camera calibration and finds the intrinsic and 2D "
"transformation between the camera and the calibration board (chessboard) "
"only using single image capture. Also, this node can be used in "
"combination with the HandEyeCalibration2DV02 node in the 2D picking "
"pipeline to perform 2D robot picking."
msgstr ""

#: ../nodes/Calibration/calibration_2d_overview.rst:5
#: ../nodes/Calibration/calibration_overview.rst:5
#: ../nodes/Calibration/hand_eye_calibration_2d_v02_overview.rst:5
#: ../nodes/Calibration/sphere_calibration_overview.rst:5 ../nodes/DA
#: Modules/da_calibration_overview.rst:5
msgid "Modes"
msgstr ""

#: ../nodes/Calibration/calibration_2d_overview.rst:7
msgid ""
"Calibrate : In this mode, camera-world calibration is performed. Note "
"that the used camera is 2D and no point cloud is used."
msgstr ""

#: ../nodes/Calibration/calibration_2d_overview.rst:8
msgid ""
"Project : In this mode, the output of the Calibrate mode is used to "
"convert a 2D pixel location detected by a mod_finder to the 3D camera "
"coordinates."
msgstr ""

#: ../nodes/Calibration/calibration_2d_overview.rst:11
msgid "Calibrate mode inputs"
msgstr ""

#: ../nodes/Calibration/calibration_2d_overview.rst:13
#: ../nodes/Calibration/calibration_2d_overview.rst:30
msgid ""
"Image (type:Image) : Image captured from the calibration tool (chessboard"
" or circle grid)."
msgstr ""

#: ../nodes/Calibration/calibration_2d_overview.rst:14
msgid ""
"Camera intrinsic (type:CameraIntrinsic) : Camera intrinsic. This input is"
" optional. If not set, the camera intrinsic will be obtained."
msgstr ""

#: ../nodes/Calibration/calibration_2d_overview.rst:15
msgid ""
"Grid Type (type:Int) : The used type of calibration tool. It can be "
"either chessboard or circle grid."
msgstr ""

#: ../nodes/Calibration/calibration_2d_overview.rst:16
#: ../nodes/Calibration/calibration_overview.rst:21 ../nodes/DA
#: Modules/da_calibration_overview.rst:19
msgid "Number of rows (type:Int) : The number of rows in the grid board."
msgstr ""

#: ../nodes/Calibration/calibration_2d_overview.rst:17
#: ../nodes/Calibration/calibration_overview.rst:22 ../nodes/DA
#: Modules/da_calibration_overview.rst:20
msgid "Number of columns (type:Int) : The number of columns in the grid board."
msgstr ""

#: ../nodes/Calibration/calibration_2d_overview.rst:18
#: ../nodes/Calibration/calibration_overview.rst:23 ../nodes/DA
#: Modules/da_calibration_overview.rst:21
msgid ""
"Row spacing (type:Double) : The distance (mm) between every two square "
"corners in a row in the chessboard or the distance between every two "
"circles in a row in the circle grid."
msgstr ""

#: ../nodes/Calibration/calibration_2d_overview.rst:19
#: ../nodes/Calibration/calibration_overview.rst:24 ../nodes/DA
#: Modules/da_calibration_overview.rst:22
msgid ""
"Column spacing (type:Double) : The distance (mm) between every two square"
" corners in a column in the chessboard or the distance between every two "
"circles in a column in the circle grid."
msgstr ""

#: ../nodes/Calibration/calibration_2d_overview.rst:20
msgid ""
"Half Window Size (type:Double) : The size of the window (mm) to detect "
"the chessboard corners. Usually set as the half size of the column/row "
"spacing. Only used when the used grid type is chessboard."
msgstr ""

#: ../nodes/Calibration/calibration_2d_overview.rst:23
msgid "Calibrate mode outputs"
msgstr ""

#: ../nodes/Calibration/calibration_2d_overview.rst:25
msgid ""
"context (type:SCalibration2dContext) : 2D calibration results including "
"the camera intrinsic and the world (calibration tool) to camera 3D "
"transformation (includes only 2D components). This would then be used in "
"the project mode."
msgstr ""

#: ../nodes/Calibration/calibration_2d_overview.rst:28
msgid "Project mode inputs"
msgstr ""

#: ../nodes/Calibration/calibration_2d_overview.rst:31
msgid ""
"Mod Finder Results (type:MapSModResultData) : The result of the "
"mod_finder node which includes the 2D orientation and pixel location "
"(usually center point) of the detected model."
msgstr ""

#: ../nodes/Calibration/calibration_2d_overview.rst:32
msgid ""
"Reference Node (type:String) : The reference calibration_2d node in "
"calibrate mode which its output will be used in the project mode."
msgstr ""

#: ../nodes/Calibration/calibration_2d_overview.rst:33
msgid ""
"Z Offset (type:Double) : The distance (mm) from the detection surface to "
"the calibration surface. For example, if the detection surface is below "
"the calibration surface for 20mm, you should input 20 and vice-versa."
msgstr ""

#: ../nodes/Calibration/calibration_2d_overview.rst:36
msgid "Project mode outputs"
msgstr ""

#: ../nodes/Calibration/calibration_2d_overview.rst:38
msgid ""
"poses (type:Map<Vec<Pose>>) : The 3D poses in camera coordinate system of"
" the 2D pixels detected by mod_finder node."
msgstr ""

#: ../nodes/Calibration/calibration_2d_procedure.rst:2
#: ../nodes/Calibration/calibration_procedure.rst:2
msgid "Procedure of Using Calibration Node"
msgstr ""

#: ../nodes/Calibration/calibration_2d_procedure.rst:4
msgid ""
"In the previous section, we provided details on the "
"HandEyeCalibration2DV02 node which obtains transformation between the "
"world and the robot virtual plane. However, in order to be able to "
"perform the 2D picking successfully, we need a way to obtain the "
"transformation between a camera and the world. This can be done using the"
" Calibration2D node which obtains the transformation between the world "
"(chessboard) and the camera ony using a single capture."
msgstr ""

#: ../nodes/Calibration/calibration_2d_procedure.rst:11
msgid ""
"By adding the Calibration2D node, you can see that this node operates in "
"two modes. One is the calibrate mode which simply usues the captured "
"image from the chessboard or circle grid to obtain the intrinsic "
"parameters of the camera as well as the transformation of camera to world"
" (gird)."
msgstr ""

#: ../nodes/Calibration/calibration_2d_procedure.rst:18
msgid ""
"The other mode of the Calibration2D node is the project mode. This mode "
"is used in the 2D picking pipeline to convert a detected 2D pixel (from a"
" mod_finder node) into the 3D world coordinate system."
msgstr ""

#: ../nodes/Calibration/calibration_2d_procedure.rst:24
msgid ""
"Note that as the picking process is 2D and as mentioned before, the "
"picking height is hardcoded. This value can be set in the Z offset filed "
"of the project mode in calibration2D node ad shown above. This is the "
"distance from the detection surface surface to the chessboard surface. If"
" the detection surface is above the calibration surface for 20mm, wou "
"should enter -20 and vice-versa."
msgstr ""

#: ../nodes/Calibration/calibration_2d_procedure.rst:27
msgid ""
"By obtaining the transformation of a 2D pixel to 3D world coordinates "
"system using the Calibration 2D node and the transformation of world to "
"robot plane from the HandEyeCalibration2DV02 Node, the transformation "
"from 2D pixels to robot base can obtained which then can be used in the "
"2D picking pipeline."
msgstr ""

#: ../nodes/Calibration/calibration_overview.rst:7
#: ../nodes/Calibration/hand_eye_calibration_2d_v02_overview.rst:7
#: ../nodes/Calibration/sphere_calibration_overview.rst:7 ../nodes/DA
#: Modules/da_calibration_overview.rst:7
msgid ""
"Accumulate : In this mode, the calibration node accumulates (loads) the "
"needed data and calibration settings to be used in the final mode for "
"calibration computation."
msgstr ""

#: ../nodes/Calibration/calibration_overview.rst:8
#: ../nodes/Calibration/hand_eye_calibration_2d_v02_overview.rst:8
#: ../nodes/Calibration/sphere_calibration_overview.rst:8 ../nodes/DA
#: Modules/da_calibration_overview.rst:8
msgid ""
"Final : In this mode, the calibration node uses the data from the "
"accumulation mode and perform the actual robot calibration."
msgstr ""

#: ../nodes/Calibration/calibration_overview.rst:9
#: ../nodes/Calibration/hand_eye_calibration_2d_v02_overview.rst:9
#: ../nodes/Calibration/sphere_calibration_overview.rst:9
msgid ""
"Load : In this mode, the calibration node loads the output from the final"
" mode for future use. This can help to load previous calibration results "
"without a need to run previous modes."
msgstr ""

#: ../nodes/Calibration/calibration_overview.rst:13
#: ../nodes/Calibration/hand_eye_calibration_2d_v02_overview.rst:12
#: ../nodes/Calibration/sphere_calibration_overview.rst:12 ../nodes/DA
#: Modules/da_calibration_overview.rst:13
msgid "Accumulate mode inputs"
msgstr ""

#: ../nodes/Calibration/calibration_overview.rst:15
msgid ""
"Hand Eye Config (type:Int) : Robot camera configuration. Either eye-to-"
"hand (calibration tool mounted on robot) or eye-in-hand (camera mounted "
"on robot)."
msgstr ""

#: ../nodes/Calibration/calibration_overview.rst:16
#: ../nodes/Calibration/hand_eye_calibration_2d_v02_overview.rst:14 ../nodes/DA
#: Modules/da_calibration_overview.rst:16
msgid "Pose (type:Pose) : Pose collected from robot read node."
msgstr ""

#: ../nodes/Calibration/calibration_overview.rst:17 ../nodes/DA
#: Modules/da_calibration_overview.rst:17
msgid "Image (type:Image) : Image captured from the calibration tool."
msgstr ""

#: ../nodes/Calibration/calibration_overview.rst:18
msgid ""
"Point Cloud (type:Cloud) : Cloud captured from the calibration tool. This"
" should be set if you are using the point cloud for calibration."
msgstr ""

#: ../nodes/Calibration/calibration_overview.rst:19
msgid ""
"Use Point cloud (type:Bool): Option to use input point cloud for "
"calibration or not."
msgstr ""

#: ../nodes/Calibration/calibration_overview.rst:20 ../nodes/DA
#: Modules/da_calibration_overview.rst:18
msgid ""
"Grid Type (type:Int) : The used type of calibration tool. It can be "
"either chessboard or grid circles."
msgstr ""

#: ../nodes/Calibration/calibration_overview.rst:25
msgid ""
"Use large circle orientation (type:Bool): Option to either use large "
"circle orientation for calibration or not. This option is available if "
"only you are using circle grids as the calibration tool. This option "
"gives flexibility in how much the grid can be rotated."
msgstr ""

#: ../nodes/Calibration/calibration_overview.rst:28
#: ../nodes/Calibration/hand_eye_calibration_2d_v02_overview.rst:17
#: ../nodes/Calibration/sphere_calibration_overview.rst:20 ../nodes/DA
#: Modules/da_calibration_overview.rst:25
msgid "Accumulate mode outputs"
msgstr ""

#: ../nodes/Calibration/calibration_overview.rst:30
msgid ""
"pointerToCalibration (type:Calibration) : This output includes the "
"information about the calibration settings alongside with the data needed"
" for performing calibration computation in the final mode."
msgstr ""

#: ../nodes/Calibration/calibration_overview.rst:31
#: ../nodes/Calibration/hand_eye_calibration_2d_v02_overview.rst:20
#: ../nodes/Calibration/hand_eye_calibration_2d_v02_overview.rst:40
#: ../nodes/Calibration/sphere_calibration_overview.rst:23
#: ../nodes/Calibration/sphere_calibration_overview.rst:43
msgid ""
"status (type:Int) : This output indicates if there were any errors during"
" the node execution. If the value is 0, no error has occurred. However, "
"if the value is non-zero, an error has occurred during execution and an "
"error message will be printed in the console."
msgstr ""

#: ../nodes/Calibration/calibration_overview.rst:34
#: ../nodes/Calibration/hand_eye_calibration_2d_v02_overview.rst:23
#: ../nodes/Calibration/sphere_calibration_overview.rst:27 ../nodes/DA
#: Modules/da_calibration_overview.rst:31
msgid "Final mode inputs"
msgstr ""

#: ../nodes/Calibration/calibration_overview.rst:36
msgid ""
"Camera intrinsic (type:CameraIntrinsic) : Camera intrinsic. This input is"
" optional. If not set, the camera intrinsic will be obtained using the "
"data loaded in the accumulate mode."
msgstr ""

#: ../nodes/Calibration/calibration_overview.rst:37
#: ../nodes/Calibration/sphere_calibration_overview.rst:29 ../nodes/DA
#: Modules/da_calibration_overview.rst:34
msgid ""
"Reference node (type:String) : The reference calibration node in "
"accumulation mode which its output will be used to perform calibration."
msgstr ""

#: ../nodes/Calibration/calibration_overview.rst:38
msgid ""
"Cost function (type:Int) :  The used cost function for calibration "
"computation."
msgstr ""

#: ../nodes/Calibration/calibration_overview.rst:39
msgid ""
"File name (type:String) : The filename used to save the outputs of the "
"node in. This file is saved in the folder 'calibrations' in the workspace"
" folder."
msgstr ""

#: ../nodes/Calibration/calibration_overview.rst:42
#: ../nodes/Calibration/hand_eye_calibration_2d_v02_overview.rst:34
#: ../nodes/Calibration/sphere_calibration_overview.rst:34 ../nodes/DA
#: Modules/da_calibration_overview.rst:38
msgid "Final mode outputs"
msgstr ""

#: ../nodes/Calibration/calibration_overview.rst:44
msgid ""
"cam_in_gripper (type:Pose) : The 3D transformation from the camera to the"
" gripper (TCP). Only has value in eye-in-hand situaltions."
msgstr ""

#: ../nodes/Calibration/calibration_overview.rst:45
msgid ""
"base_in_world (type:Pose) : The 3D transformation from robot base to the "
"world (calibration board). Only has value in eye-in-hand situaltions."
msgstr ""

#: ../nodes/Calibration/calibration_overview.rst:46 ../nodes/DA
#: Modules/da_calibration_overview.rst:42
msgid ""
"cam_in_base (type:Pose) : The 3D transformation from camera to robot "
"base. Only has value in eye-to-hand situations."
msgstr ""

#: ../nodes/Calibration/calibration_overview.rst:47 ../nodes/DA
#: Modules/da_calibration_overview.rst:43
msgid ""
"gripper_in_world (type:Pose) : The 3D transformation from gripper (TCP) "
"to world (calibration board). Only has value in eye-to-hand situations."
msgstr ""

#: ../nodes/Calibration/calibration_overview.rst:48
msgid ""
"pointerToCalibration (type:Calibration) : This output includes the "
"information about the calibration settings alongside with the results of "
"the calibration from the final mode."
msgstr ""

#: ../nodes/Calibration/calibration_overview.rst:49
msgid ""
"status (type:Int) : This output indicates if there were any errors during"
" the node excecution. If the value is 0, no error has occured. However, "
"if the value is non-zero, an error has occurred during execution and an "
"error message will be printed in the console."
msgstr ""

#: ../nodes/Calibration/calibration_overview.rst:52
#: ../nodes/Calibration/hand_eye_calibration_2d_v02_overview.rst:43
#: ../nodes/Calibration/sphere_calibration_overview.rst:47 ../nodes/DA
#: Modules/da_calibration_overview.rst:48
msgid "Load mode inputs"
msgstr ""

#: ../nodes/Calibration/calibration_overview.rst:54
#: ../nodes/Calibration/hand_eye_calibration_2d_v02_overview.rst:45
#: ../nodes/Calibration/sphere_calibration_overview.rst:49 ../nodes/DA
#: Modules/da_calibration_overview.rst:51
msgid ""
"File name (type:String) : The filename to load the outputs from the final"
" mode."
msgstr ""

#: ../nodes/Calibration/calibration_overview.rst:57
#: ../nodes/Calibration/hand_eye_calibration_2d_v02_overview.rst:49
#: ../nodes/Calibration/sphere_calibration_overview.rst:52 ../nodes/DA
#: Modules/da_calibration_overview.rst:54
msgid "Load mode outputs"
msgstr ""

#: ../nodes/Calibration/calibration_overview.rst:59
#: ../nodes/Calibration/sphere_calibration_overview.rst:54 ../nodes/DA
#: Modules/da_calibration_overview.rst:56
msgid "Same as the final mode."
msgstr ""

#: ../nodes/Calibration/calibration_procedure.rst:4 ../nodes/DA
#: Modules/da_calibration_procedure.rst:5
msgid ""
"In order to perform calibration using this node, we need to capture "
"camera images of the calibration tool from different views. The "
"calibration tools that can be used in this node are grid circles and gird"
" chessboards that examples of each are shown below."
msgstr ""

#: ../nodes/Calibration/calibration_procedure.rst:16
msgid ""
"Note that the captured images should contain a variety of images with "
"different position and rotation angles to ensure a good calibration "
"result. Once you have captured calibration images, you can add the "
"calibration node into the flowchart to perform calibration (Templates "
"provided in the software). When adding this node to the flowchart, you "
"will see the option for choosing the calibration mode. We provide three "
"modes for the calibration node. First, the accumulation mode is used to "
"load the captured images, poses and point clouds from the calibration "
"board and detect the corner points (chessboard) or circle center points "
"(circle board). When you choose the accumulation mode, you will be able "
"to set different options and inputs."
msgstr ""

#: ../nodes/Calibration/calibration_procedure.rst:30
msgid ""
"As shown in the above image, you have to choose the hand-eye "
"configuration. Also, the other inputs include the captured image, robot "
"pose (base in gripper) and point cloud for each robot position. In "
"addition, you have to choose the used grid board type (calibration tool)."
" Note that you can see the result of the accumulation node (detected "
"points) by clicking on the node. In case the algorithm is not able to "
"detect the corner/circle points, the image will be skipped and not used "
"for final calibration."
msgstr ""

#: ../nodes/Calibration/calibration_procedure.rst:34 ../nodes/DA
#: Modules/da_calibration_procedure.rst:35
msgid ""
"After obtaining the corner/circle points, it is time to use the results "
"and inputs from the accumulation mode to perform robot-camera "
"calibration. This can be done by adding another calibration node in the "
"flowchart and setting the mode to the final mode. The final mode will "
"perform the main computation for the calibration."
msgstr ""

#: ../nodes/Calibration/calibration_procedure.rst:41
msgid ""
"In the final node, you have to specify the reference accumulation node, "
"so, the results then can be used for calibration. Also, as the "
"calibration algorithm will use an optimization based method to obtain the"
" calibration results, you need to choose the used cost function. In case "
"of using a 3D camera and 3D picking, it is a better option to use the "
"RPDepth cost function as our experiments show better results for this "
"cost function. However, note that when using RPDepth, you will need to "
"set the option \"using the point cloud\" in the accumulation mode. By "
"running the calibration node in the final mode, the calibration results "
"will be obtained. More specifically, the main outputs of the final mode "
"are the camera to gripper (TCP) and base to board (world) 3D "
"transformations in the eye-in-hand scenario. This will be camera to base "
"and gripper (TCP) to board 3D transformations in the eye-to-hand "
"scenario. These transformations then can be used in the picking flowchart"
" for different robot picking operations."
msgstr ""

#: ../nodes/Calibration/calibration_procedure.rst:47 ../nodes/DA
#: Modules/da_calibration_procedure.rst:48
msgid ""
"Another existing mode for calibration mode is the load mode which simply "
"loads the result file saved in the final mode. This can be used to "
"visualize the result of the calibration without a need to run the "
"previous nodes."
msgstr ""

#: ../nodes/Calibration/hand_eye_calibration_2d_v02.rst:2
msgid "HandEyeCalibration2DV02 node"
msgstr ""

#: ../nodes/Calibration/hand_eye_calibration_2d_v02.rst:4
msgid ""
"This node is used to perform robot-world 2D calibration for 2D random bin"
" picking. In other words , it finds the 2D transformation between the "
"world (chessboard) and a virtual robot plane."
msgstr ""

#: ../nodes/Calibration/hand_eye_calibration_2d_v02_overview.rst:19
#: ../nodes/Calibration/hand_eye_calibration_2d_v02_overview.rst:39
msgid ""
"pointerToHandEyeCalibration2dV02 (type:HandEyeCalibration2dV02) : This "
"output includes the information about the calibration settings alongside "
"with the data needed for performing calibration computation in the final "
"mode."
msgstr ""

#: ../nodes/Calibration/hand_eye_calibration_2d_v02_overview.rst:25
msgid ""
"Reference node (type:String) : The reference calibration in accumulation "
"mode which its output will be used to perform calibration."
msgstr ""

#: ../nodes/Calibration/hand_eye_calibration_2d_v02_overview.rst:26
msgid ""
"File name (type:String) : The filename used to save the outputs of the "
"node. The outputs will be saved in a file with specified name you defined"
" in the \"pin_calibrations\" folder in the workspace directory."
msgstr ""

#: ../nodes/Calibration/hand_eye_calibration_2d_v02_overview.rst:27
msgid ""
"Number of rows (type:Int) : Number of the rows in the used chessboard "
"that robot pin touches. Should be a positive integer."
msgstr ""

#: ../nodes/Calibration/hand_eye_calibration_2d_v02_overview.rst:28
msgid ""
"Number of cols (type:Int) : Number of columns in the used chessboard that"
" the robot pin touches. Should be a positive integer."
msgstr ""

#: ../nodes/Calibration/hand_eye_calibration_2d_v02_overview.rst:29
msgid ""
"Row spacing (type:Double) : The distance (mm) between each pin location "
"on the chessboard in a row. Should be a positive double."
msgstr ""

#: ../nodes/Calibration/hand_eye_calibration_2d_v02_overview.rst:30
msgid ""
"Column Spacing (type:Double) : The distance (mm) between each pin "
"location on the chessboard in a column. Should be a positive double."
msgstr ""

#: ../nodes/Calibration/hand_eye_calibration_2d_v02_overview.rst:31
msgid ""
"Use initial guess (type:Bool): The initial guess for the translation of "
"the pin to TCP. This will be then used as optimization initialization "
"when performing calibration computation. The translation value is zero if"
" not set."
msgstr ""

#: ../nodes/Calibration/hand_eye_calibration_2d_v02_overview.rst:36
msgid ""
"PlaneToWorld (type:Pose) : The 3D transformation from the robot plane to "
"world (chessboard). Note that as we are performing 2D calibration, this "
"transformation only includes 2D components (x,y and Rz)."
msgstr ""

#: ../nodes/Calibration/hand_eye_calibration_2d_v02_overview.rst:37
msgid ""
"WorldToPlane (type:Pose) : The 3D transformation from world (chessboard) "
"to robot plane. Note that as we are performing 2D calibration, this "
"transformation only includes 2D components (x,y and Rz)."
msgstr ""

#: ../nodes/Calibration/hand_eye_calibration_2d_v02_overview.rst:38
msgid ""
"PinToTcp (type:Pose) : The 3D translation from pin to robot TCP. Note "
"that as we are performing 2D calibration, this translation only includes "
"2D components (x,y)."
msgstr ""

#: ../nodes/Calibration/hand_eye_calibration_2d_v02_overview.rst:51
msgid "The same as the final mode."
msgstr ""

#: ../nodes/Calibration/hand_eye_calibration_2d_v02_procedure.rst:2
msgid "Procedure for Using HandEyeCalibration2DV02 Node"
msgstr ""

#: ../nodes/Calibration/hand_eye_calibration_2d_v02_procedure.rst:4
msgid ""
"This node is one of the nodes used to perform robot-world 2D calibration "
"for random bin picking. More specifically, this node calculates the 2D "
"transformation between a robot virtual plane and the world (chessboard) "
"where it is assumed that bin picking is performed on a 2D plane. In other"
" words, this type of calibration can be used in scenarios where the "
"picking height is constant. An overview of the calibration setup is shown"
" below."
msgstr ""

#: ../nodes/Calibration/hand_eye_calibration_2d_v02_procedure.rst:11
msgid ""
"As shown above, this type of calibration requires you to place the "
"chessboard on the object tray. We will refer to the chessboard coordinate"
" system as the world coordinate system in the rest of this section. Also,"
" a pin is attached to the robot arm and a robot virtual plane is defined "
"using the robot pendent which should be parallel to the chessboard. Each "
"robot type (robot brand) provides a way to define a virtual plane. Please"
" refer to your robot manual for more details on how to do this."
msgstr ""

#: ../nodes/Calibration/hand_eye_calibration_2d_v02_procedure.rst:15
msgid ""
"In order to create this virtual plane, you need to define 3 different TCP"
" positions. Then, the robot will automatically create a virtual plane "
"with the Z axis directing upwards. Note that for the case of our "
"calibration, we need to define the 3 TCP positions such that the pin "
"touches the 3 corners of the chessboard on the tray."
msgstr ""

#: ../nodes/Calibration/hand_eye_calibration_2d_v02_procedure.rst:22
msgid ""
"Once this virtual plane is created, We need to gather the calibration "
"data needed. For this purpose, you need to move the the pin to corner "
"points in the chessboard. The choice of the number of chessboard points "
"to touch is arbitrary. However, our experiment with 12 points (3 rows and"
" 4 columns) and using a row and column spacing of 2 squares is shown to "
"give us a good and stable result. To better underhand this,  as shown in "
"the image below, you have to guide the robot to touch (nearly touch) the "
"corner points of the chessboard in a zig zag pattern. Note that the "
"distance between every two pin points in a row is called the row spacing "
"value and the distance between every two pin points in a column is called"
" the column spacing value (2 squares in this image). When touching the "
"chessboard with the pin, the TCP value in the plane should have a Z value"
" of near zero. Also, make sure the Rx and Ry values should be set to "
"zero. Finally, use a variety of random rotation values for the Rz at each"
" pin point on the chessboard to ensure a good calibration result. Once "
"the robot pose (TCP in plane) for each pin position is collected, you "
"need to save them for further use of the HandEyeCalibration2DV02 node. "
"(Please refer to 2D picking flowchart template)."
msgstr ""

#: ../nodes/Calibration/hand_eye_calibration_2d_v02_procedure.rst:29
msgid ""
"Now that the data has been collected, the HandEyeCalibration2DV02 node "
"can be used to perform robot plane- world calibration. As mentioned "
"before, the goal of this node is to find the 2D transformation between "
"the robot plane and the world (chessboard). When adding the "
"HandEyeCalibration2DV02 node, you will see that this node has three "
"modes. The first mode is the accumulation mode which is used to load the "
"calibration data (robot poses) needed for the calibration calculation."
msgstr ""

#: ../nodes/Calibration/hand_eye_calibration_2d_v02_procedure.rst:36
msgid ""
"After accumulation, the next step is to perform the calibration "
"computation and find the needed transformations. This is done using the "
"final mode of HandEyeCalibration2DV02 node."
msgstr ""

#: ../nodes/Calibration/hand_eye_calibration_2d_v02_procedure.rst:42
msgid ""
"The output of the final mode is the 2D transformation of plane to world "
"and world to plane alongside with the 2D translation of pin to TCP (saved"
" in a 3D transformation format only including 2D components). The inputs "
"of the node in the final mode include the reference node which is the "
"reference accumulation node. Also, you have to specify the number of used"
" row and columns for the pin points and distance between these points in "
"each row and column (row spacing and column spacing). Also, you can "
"specify an initial value for the translation of pin to TCP which is then "
"used as an initialization for the optimization performed for calibration."
" Finally, the filename is the name of the file that the calibration "
"results will be saved into. This then can be used to use the load mode to"
" load the results later on without a need for performing the previous "
"steps again as shown in the image below."
msgstr ""

#: ../nodes/Calibration/index.rst:2
msgid "Calibration Nodes"
msgstr ""

#: ../nodes/Calibration/pose_generation.rst:2
msgid "Pose Generation node"
msgstr ""

#: ../nodes/Calibration/pose_generation.rst:4
msgid ""
"This node generates a set of robot poses with a specific pattern which "
"then can be used for data capturing used for Calibration Node, DA "
"Calibration Node or Sphere Calibration Node."
msgstr ""

#: ../nodes/Calibration/pose_generation_overview.rst:4
msgid ""
"The Pose Generation node is responsible to generate multiple poses for "
"the robot (gripper pose inside the base coordinates) that can be used for"
" calibration."
msgstr ""

#: ../nodes/Calibration/pose_generation_overview.rst:6
msgid "Three moving types are available:"
msgstr ""

#: ../nodes/Calibration/pose_generation_overview.rst:8
msgid "Circle"
msgstr ""

#: ../nodes/Calibration/pose_generation_overview.rst:9
msgid "Square"
msgstr ""

#: ../nodes/Calibration/pose_generation_overview.rst:10
msgid "Trapezoid"
msgstr ""

#: ../nodes/Calibration/pose_generation_overview.rst:16
msgid ""
"Ref Gripper To Base: (DataType: Pose)A Homogeneous matrix that has the "
"initial pose of the gripper that will be used in order to generate the "
"other poses."
msgstr ""

#: ../nodes/Calibration/pose_generation_overview.rst:18
msgid ""
"Camera To Gripper: (DataType: Pose)A Homogeneous that could have an "
"initial estimate for the relationship between the camera and the gripper "
"(or the calibration board and the gripper if the Eye-To-Hand "
"configuration is being used). If unknown, an identity matrix is set."
msgstr ""

#: ../nodes/Calibration/pose_generation_overview.rst:23
msgid "poses: (DataType: vector<Pose>) a vector of generated poses"
msgstr ""

#: ../nodes/Calibration/pose_generation_procedure.rst:2
msgid "Procedure of using the Pose Generation Node"
msgstr ""

#: ../nodes/Calibration/pose_generation_procedure.rst:4
msgid ""
"Usually inside an Auto Calibration flowchart to generate a number of "
"poses."
msgstr ""

#: ../nodes/Calibration/pose_generation_procedure.rst:6
msgid ""
"The following procedure provides a basic methodology for using the Pose "
"Generation Node:"
msgstr ""

#: ../nodes/Calibration/pose_generation_procedure.rst:8
msgid "Set up the input for the node"
msgstr ""

#: ../nodes/Calibration/pose_generation_procedure.rst:9
msgid "Adjust parameters to correctly config the process type"
msgstr ""

#: ../nodes/Calibration/pose_generation_procedure.rst:10
msgid ""
"The output of the poses can be used for Robot Write Node to tell the "
"robot where to go"
msgstr ""

#: ../nodes/Calibration/sphere_calibration.rst:2
msgid "Sphere Calibration node"
msgstr ""

#: ../nodes/Calibration/sphere_calibration.rst:4
msgid ""
"This node performs 3D robot calibration using a sphere as the calibration"
" tool. This node can be run in three different modes."
msgstr ""

#: ../nodes/Calibration/sphere_calibration_overview.rst:14
msgid ""
"Hand Eye Config (type:Pose) : Robot camera configuration. Either eye-to-"
"hand (sphere mounted on robot arm) or eye-in-hand (camera mounted on "
"robot)."
msgstr ""

#: ../nodes/Calibration/sphere_calibration_overview.rst:15
msgid "Robot Pose (type:Pose) : Robot pose (TCP in base)."
msgstr ""

#: ../nodes/Calibration/sphere_calibration_overview.rst:16
msgid "Sphere Pose (type:Pose) : Pose of detected spheres."
msgstr ""

#: ../nodes/Calibration/sphere_calibration_overview.rst:17
msgid ""
"Use Initial guess (type:Bool) : An option to set the initial value for "
"the translation of gripper (TCP) to camera in eye-in-hand scenario or the"
" translation of sphere in gripper (TCP) in eye-to-hand scenario."
msgstr ""

#: ../nodes/Calibration/sphere_calibration_overview.rst:22
#: ../nodes/Calibration/sphere_calibration_overview.rst:42
msgid ""
"pointerToSphereCalibration (type:SphereCalibration) : This output "
"includes the information about the calibration settings alongside with "
"the data needed for performing calibration computation in the final mode."
msgstr ""

#: ../nodes/Calibration/sphere_calibration_overview.rst:30
msgid ""
"File name (type:String) : The filename used to save the outputs of the "
"node in. This file is saved in the folder 'sphere_calibrations' in the "
"workspace folder."
msgstr ""

#: ../nodes/Calibration/sphere_calibration_overview.rst:36
msgid ""
"gripper_in_cam (type:Pose) : The 3D transformation from the gripper (TCP)"
" to camera. Only has value in eye-in-hand situations."
msgstr ""

#: ../nodes/Calibration/sphere_calibration_overview.rst:37
msgid ""
"cam_in_gripper (type:PPose) : The 3D transformation from the camera to "
"gripper (TCP). Only has value in eye-in-hand situations."
msgstr ""

#: ../nodes/Calibration/sphere_calibration_overview.rst:38
msgid ""
"sphere_in_base (type:PPose) : The 3D translation from sphere to robot "
"base. Only has value in eye-in-hand situations."
msgstr ""

#: ../nodes/Calibration/sphere_calibration_overview.rst:39
msgid ""
"base_in_cam (type:Pose) : The 3D transformation from robot base to camera"
" . Only has value in eye-to-hand situations."
msgstr ""

#: ../nodes/Calibration/sphere_calibration_overview.rst:40
msgid ""
"cam_in_base (type:PPose) : The 3D transformation from camera to robot "
"base. Only has value in eye-to-hand situations."
msgstr ""

#: ../nodes/Calibration/sphere_calibration_overview.rst:41
msgid ""
"sphere_in_gripper (type:Pose) : The 3D transformation from sphere to the "
"gripper (TCP). Only has value in eye-to-hand situations."
msgstr ""

#: ../nodes/Calibration/sphere_calibration_procedure.rst:2
msgid "Procedure for Using Sphere Calibration Node"
msgstr ""

#: ../nodes/Calibration/sphere_calibration_procedure.rst:4
msgid ""
"The functionality of sphere calibrator node is very similar to "
"calibration node. The main difference lies in the used calibration tool "
"and optimization method used for calibration. An example of the used "
"sphere tool is shown below (orange sphere). This sphere can either be "
"mounted to the robot arm (eye-in-hand) or could have a static position "
"(eye-to-hand). Again same as the calibration node, you need to capture "
"different 3D images from the calibration tool. Note that for each robot "
"and sphere position, the robot pose and the 2D and 3D image of the scene "
"should be captured. The next step is to detect the spheres in each "
"capture to obataion the sphere poses in each capture. For this please "
"refer to the sphere calibration flowchart template."
msgstr ""

#: ../nodes/Calibration/sphere_calibration_procedure.rst:13
msgid ""
"Once you have captured calibration images and detected the sphere poses, "
"you can add the sphere calibration node into the flowchart to perform "
"calibration. When adding this node to the flowchart, you will see the "
"option for choosing the calibration mode. We provide three modes for the "
"sphere calibration node. First, the accumulation mode is used to load the"
" calculated sphere poses and robot poses for each robot position. When "
"you choose the accumulation mode, you will be able to set different "
"options and inputs."
msgstr ""

#: ../nodes/Calibration/sphere_calibration_procedure.rst:23
msgid ""
"As shown in the image above, you have to choose the hand-eye "
"configuration. Also, the other inputs include the robot pose, sphere pose"
" (position of sphere center point in the point cloud).  In the sphere "
"calibration case, the transformations to be obtained are the 3D "
"transformation of TCP to camera and the translation of sphere to base for"
" eye-in-hand scenarios. This would be the 3D transformation of base to "
"camera and the translation of sphere to TCP in the eye-to-hand case. "
"Also, there is an option to set initial value for the translation of TCP "
"to camera (eye-in-hand) and sphere to gripper (eye-to-hand). This is then"
" used as an initialization for the optimization. The default value for "
"this case is zero translation."
msgstr ""

#: ../nodes/Calibration/sphere_calibration_procedure.rst:27
msgid ""
"After accumulation, the next step is to perform robot-camera calibration."
" This can be done by adding another sphere calibration node in the "
"flowchart and setting the mode to final mode. The final mode will perform"
" the main computation for the calibration."
msgstr ""

#: ../nodes/Calibration/sphere_calibration_procedure.rst:34
msgid ""
"In the final mode, you have to specify the reference accumulation node, "
"so, the results then can be used for calibration. Also, you have to "
"determine a file name where the calibration results (obtained "
"transformations) will be saved in. By running the calibration node in the"
" final mode, the calibration results will be obtained. More specifically "
"the outputs of the final mode are the gripper to camera, camera to "
"gripper 3D transformations and sphere to base translation for the eye-in-"
"hand scenario. This will be base to camera and camera to base 3D "
"transformations and the translation of sphere to gripper for the eye-to-"
"hand scenario. These transformations then can be used in the picking "
"flowchart for different robot operations."
msgstr ""

#: ../nodes/Calibration/sphere_calibration_procedure.rst:40
msgid ""
"Another existing mode for sphere calibration mode is the load mode which "
"simply loads the result file saved in the final mode. This can be used to"
" load the calibration results without a need to run the previous nodes."
msgstr ""

#: ../nodes/DA Modules/Code Node.rst:2 Reader
msgid "Code Reader Node"
msgstr ""

#: ../nodes/DA Modules/Code Node.rst:5 Reader
msgid "Detect code on image."
msgstr ""

#: ../nodes/DA Checker Modules/Color Node.rst:2
msgid "Color Checker Node"
msgstr ""

#: ../nodes/DA Checker Modules/Color Node.rst:4
msgid "Do color matching or color segmentation on a color image."
msgstr ""

#: ../nodes/DA Alignment Modules/DA Node.rst:2
msgid "Da Alignment Node"
msgstr ""

#: ../nodes/DA Alignment Modules/DA Node.rst:5
msgid ""
"Align model point cloud to scene point cloud. Similar to regular "
"alignment node."
msgstr ""

#: ../nodes/DA Calibration Modules/DA Node.rst:2
msgid "Da Calibration Node"
msgstr ""

#: ../nodes/DA Calibration Modules/DA Node.rst:4
msgid ""
"This node like Calibration node performs 3D robot calibration using "
"chessboard or circle grid as the calibration tool. However, it uses a "
"different approach. This node can be run in three different modes."
msgstr ""

#: ../nodes/DA CloudNDepth Conv Modules/DA Node.rst:2
msgid "Da Depth N Cloud Conv Node"
msgstr ""

#: ../nodes/DA CloudNDepth Conv Modules/DA Node.rst:4
msgid ""
"Generate calibrated depth map image from point cloud, or generate point "
"cloud from calibrated depth map."
msgstr ""

#: ../nodes/DA CloudNDepth Conv Modules/DA Node.rst:9
msgid "Use Case:"
msgstr ""

#: ../nodes/DA CloudNDepth Conv Modules/DA Node.rst:7
msgid ""
"When we need a calibrated depth image from point cloud to do 3d searching"
" in node such as 3d mod_finder, metrology node, measurement node."
msgstr ""

#: ../nodes/DA Modules/Measurement Node.rst:2
msgid "Measurement Node"
msgstr ""

#: ../nodes/DA Modules/Measurement Node.rst:5
msgid "Find and measure edge, circle, stripe on a gray image."
msgstr ""

#: ../nodes/DA Modules/Metrology Node.rst:2
msgid "Metrology Node"
msgstr ""

#: ../nodes/DA Modules/Metrology Node.rst:5
msgid ""
"Define, Detect or Calculate features such as edge, circle, and point on a"
" gray image. Calculate value information such as length of segment and "
"radius of circle and arc."
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:2
msgid "Mod Finder Node"
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:6
msgid ""
"The DaoAI Mod Finder engine used an image pattern feature to find the "
"object in 2D space, then used 3D space conversion to map it to 3D space. "
"Usually at the end, it will go through point cloud alignment node to "
"improve the 3D position accuracy."
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:8
msgid "The Mod Finder can be configured to find 2D or 3D models."
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:11
msgid "Input and Output"
msgstr ""

#: ../nodes/DA ../nodes/Flowchart_control/Break Finder Modules/Mod Node.rst:14
#: Node.rst:27 Node.rst:42
msgid "Type"
msgstr ""

#: ../nodes/DA ../nodes/Flowchart_control/Break
#: ../nodes/Flowchart_control/Condition ../nodes/Flowchart_control/Constant
#: ../nodes/Flowchart_control/Continue ../nodes/Flowchart_control/Flowchart
#: ../nodes/Flowchart_control/Halt ../nodes/Flowchart_control/Loop
#: ../nodes/Flowchart_control/Switch Finder Modules/Mod
#: Modules/da_cloudndepth_overview.rst:16 Node.rst:10 Node.rst:14 Node.rst:27
#: Node.rst:42
msgid "Description"
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:16
msgid "Image (2D Mod Finder)"
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:16 Node.rst:33
msgid "Map<Image>"
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:16 Node.rst:20
msgid "The source that is used to search for model."
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:18
msgid "or"
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:20
msgid "DA_Depth_Cloud_result (3D Mod Finder)"
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:20
msgid "Da_Depth_N_Cloud_Conv_Result"
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:21
msgid ""
"The DA_Depth_Cloud_result is the output of the \"DA CloudNDepth Conv\" "
"node."
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:22
msgid "It is the combination of a Da Depth Map and a Point Cloud."
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:29
msgid "labelledPose2dSequence"
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:29
msgid "Vec<Pose2D>"
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:29
msgid "Vector of pose 2d preserving order from labelled mask sequence."
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:31
msgid "labelledPose3dSequence"
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:31
msgid "Vec<Pose3D>"
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:31
msgid "Vector of pose 3d preserving order from labelled mask sequence."
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:33
msgid "modelMasks"
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:33
msgid "A map of model masks."
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:35
msgid "modelPoses2D"
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:35
msgid "Map<Vec<Pose2D>>"
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:35
msgid "A map of vector of 2d poses."
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:37
msgid "modelPoses3D"
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:37
msgid "Map<Vec<Pose3D>>"
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:37
msgid "A map of vector of 3d poses."
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:39
msgid "numFound"
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:39
msgid "Int"
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:39
msgid "The total number of occurrences found."
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:41
msgid "result"
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:41
msgid "ModFinderResult"
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:41
msgid "A map, mapping “model_name” to “vector of occurrences of this model”."
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:43
msgid "success"
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:43
msgid "Bool"
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:43
msgid "Boolean value indicating the search is successful."
msgstr ""

#: ../nodes/DA Finder Modules/Mod Modules/code_reader_overview.rst:22
#: Modules/color_checker_overview.rst:16 Node.rst:47
msgid "Node Settings"
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:48
msgid "The following screen shots demonstrate the settings of the 2D mod finder."
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:50
msgid ""
"The only difference between the settings of 2D mod finder and the 3D mod "
"finder is the \"Image\" input in the \"Source\" section for 2D is "
"replaced by \"Da Depth Map And Point Cloud\" for 3D."
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:53
msgid "Source Parameters"
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:58
msgid "**Image**:"
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:60
msgid ""
"The source that is used to search for model. Using link expression to "
"link the image."
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:63
msgid "**Time Out**: (Default value: 2000 ms)"
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:65
msgid ""
"The time limit for the node to run. When the running time of the node "
"reaches the time limit. The node will terminate and return the current "
"output."
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:68
msgid "**Use labelled mask sequence**:"
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:70
msgid "Refer to the \"Search Model In Labelled Mask Sequence\" section below."
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:74
msgid "Algorithm Parameters"
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:80
msgid "**Total Occurrences**: Range [0,∞) (Default value: ONE)"
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:82
msgid ""
"The number of occurrences for each model to search. The occurrence can be"
" set to any positive number. If the number of detected objects is larger "
"than the total occurrences number, the objects with the highest "
"acceptance will be returned. If the occurrence number is larger than the "
"number of detected objects, all of them will show. The Total Occurrences "
"can be set to \"ALL\"."
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:89
msgid "(left: occurrences = 1, middle: occurrences = 2, right: occurrences = ALL)"
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:98
msgid "**Speed**: Range [1,4] (Default value: MEDIUM)"
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:100
msgid "The speed of searching. Larger value means faster speed but less accuracy."
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:103
msgid "**Accuracy**: Range [1,3]  (Default value: DISABLE)"
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:105
msgid ""
"The accuracy of searching. Larger value means higher accuracy but slower "
"speed."
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:109
msgid "Edge Selection Parameters"
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:116
msgid "**Smoothness**: Range [0,100) (Default value: 50)"
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:118
msgid ""
"The noise reduction used during edge extraction. Larger value means "
"stronger noise reduction. A high smoothness will only accept smooth "
"edges, and low smoothness will accept sharp edges."
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:121
msgid "(left: smoothness = 100, right: smoothness = 1)"
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:129
msgid "**Detail Level**: Range [1,3] (Default value: MEDIUM)"
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:131
msgid ""
"The level of detail during edge extraction. The detail level determines "
"what is considered as an edge/background. A larger value means more edges"
" are extracted."
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:134
msgid "**Shared Edge**: Range [0,1]  (Default value: DISABLE)"
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:136
msgid "Whether edges are shared between different occurrences."
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:140
msgid "Models"
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:141
msgid ""
"The model is defined from the scene, or it can be imported from a "
"DL_Segment node using a labelled mask sequence. For the details of the "
"defining or import process, please check the \"Procedure to use\" "
"section. This section focuses on the properties of models."
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:145
msgid ""
"You can adjust the details of the model in the model config page. Double "
"click or select model and click edit button to open model config page."
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:151
msgid "**Label**: (Default value: -1)"
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:153
msgid ""
"To distinguish model from the DL segmentation node when labelled mask "
"sequence is used."
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:155
msgid "**Acceptance**: Range [0,100] (Default value: MEDIUM)"
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:157
msgid ""
"The minimum matching score where an occurrence is accpeted. An occurrence"
" will be returned only if the match score between the target and the "
"model is greater than or equal to this level."
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:161
msgid "**Certainty**: Range [0,100] (Default value: HIGH)"
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:163
msgid ""
"Sets the certainty level for the score, as a percentage. If both the "
"score and target scores are greater than or equal to their respective "
"certainty levels, the occurrence is considered a match, without searching"
" the rest of the target for better matches (provided the specified number"
" of occurrences has been found)."
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:169
msgid "**Polarity**:"
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:171
msgid ""
"The expected polarity of occurrences, compared to that of the model. If "
"the model is a white circle in black background, “SAME” will search for "
"white circle in black background, “REVERSE” will search black circle in "
"white background, and “ANY” will search any circle in any background as "
"long as the it is an edge."
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst
msgid "scale"
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:178
msgid "100%"
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:180
msgid "**X, Y**:"
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:182
msgid ""
"The offsets to set the reference point. The X and Y are the X-offset (in "
"pixels) and the Y-offset (in pixels) of the origin of the model's "
"reference axis, relative to the model origin. The top left corner is (0, "
"0)."
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:185
msgid ""
"You can also define reference points in the model image by clicking the "
"“Define Ref Point” of the model. This will enter interactor mode where "
"you need to select a point as a reference point. Normally the reference "
"point is the center of all the edge pixels. It is recommended to use the "
"default reference point."
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:191
msgid "**Angle**: Range [0, 360]"
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:193
msgid ""
"The nominal search angle in degrees. This is the angle to find the "
"model's reference axis."
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:195
msgid "**Search Region**: (Default value: Whole Image)"
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:197
msgid ""
"The search region can be set to the \"Whole Image\" or a specified region"
" of the Image."
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:203
msgid "*Top Left X*:"
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:203
msgid "The top left starting X pixel value."
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:206
msgid "*Top Left Y*:"
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:206
msgid "The top left starting Y pixel value."
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:209
msgid "*Size X*:"
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:209
msgid "The X dimension size of the search area in pixels."
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:212
msgid "*Size Y*:"
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:212
msgid "The Y dimension size of the search area in pixels."
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:214
msgid ""
"For example, if the interested search region is in the top left corner of"
" the image with a size of 1000*1000 pixels, the parameters should be set "
"as (0, 0, 1000, 1000)."
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:217
msgid ""
"Alternatively, you can define the search region in the target image by "
"clicking “Define Search Region” and draw a rectangular ROI on target "
"image."
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:223
msgid "**Search Scale**:"
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:225
msgid "Sets whether to search for only models within a specified scale range."
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:231
msgid "Nominal scale: Range [0.5, 2.0] (Default value: 1.0)"
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:231
msgid "The nominal scale used in scale range calculations."
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:234
msgid "Min scale: Range [1.0, 2.0] (Default value: 2.0)"
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:234
msgid "The min scale used in scale range calculations."
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:237
msgid "Max scale: Range [0.5, 1.0] (Default value: 0.5)"
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:237
msgid "The max scale used in scale range calculations."
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:239
msgid "**Search Angle**:"
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:241
msgid "Sets whether to search for only models within a specified angle range."
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:247
msgid "Delta Neg Angle:"
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:247
msgid ""
"Controls the lower limit of the angular range, relative to the reference "
"angle (Model Ref Angle)."
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:250
msgid "Delta Pos Angle:"
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:250
msgid ""
"Controls the upper limit of the angular range, relative to the reference "
"angle (Model Ref Angle)."
msgstr ""

#: ../nodes/DA ../nodes/Flowchart_control/Break Finder Modules/Mod Node.rst:61
#: Node.rst:253
msgid "Procedure to use"
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:256
msgid "2D Mod Finder Example"
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:260
msgid "Open a workspace in DaoAI Vision Studio."
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:264
msgid "Insert a Camera node to get the source image."
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:268
msgid ""
"A virtual image is used to demonstrate. Refer to System Overview, "
"Tutorials on how to connect to camera."
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:272
msgid ""
"Insert a Mod Finder node to find the T tube, select \"2D\" when creating "
"the node."
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:276
msgid ""
"Click on the blue dot on the right side of \"Image\" to link the image "
"from the camera node above as input."
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:280
msgid ""
"Expand the \"Out/main_flowchart.camera_node\" on the left window of the "
"LinkExpressionDialog. Click the \"image\" then Apply."
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:284 Node.rst:356
msgid ""
"Create a model to let the node know what it should be looking for. Click "
"on the \"+\" to create a model."
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:288 Node.rst:360
msgid "Name the model then \"Confirm\"."
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:290
msgid ""
"9. The display on the left window enters Interactor mode. Use mouse "
"carefully select the region that contains the desired model."
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:297
msgid ""
"Run the Mod Finder node. The edges of found objects are extracted by red "
"line in the image display."
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:301
msgid ""
"The default value of \"Total Occurrences\" is one. Set it to all to "
"detect all the object."
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:305
msgid "Run the Mod Finder node. Five objects are detected."
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:309
msgid ""
"Adjust the parameter of the model to find all the objects. The model "
"appears under the \"Models\" section. Double click it to open the model "
"parameters configurator."
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:313
msgid ""
"Click on the \"Draw Mask\", then use mouse to cover all the area until "
"only the edge of the model is extracted by red lines."
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:318
msgid "Run the Mod Finder node. All of the objects are detected."
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:321
msgid "3D Mod Finder Example"
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:323
msgid "**Repeat the step 1 to 3 from the above example.**"
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:327
msgid ""
"Insert a Mod Finder node to find the T tube, select \"3D\" when creating "
"the node."
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:329
msgid ""
"3. **The 3D Mod Finder takes a \"Da Depth Map And Point Cloud\" as input."
" Insert a \"DA CloudNDepth Conv\" node under Camera node. Select \"DA "
"PointCloud -> DA depth map\" when creating the node.**"
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:340
msgid ""
"Link the point cloud from the above camera node as the input of the \"DA "
"CloudNDepth Conv\" node."
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:344
msgid ""
"Run the \"DA CloudNDepth Conv\" node. The display enters interaction "
"mode. Adjust the adjust box to contain the region of interest."
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:348
msgid "Exit the interactor, the depth map is displayed."
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:352
msgid ""
"Select the Mod Finder node. Link the result from the \"DA CloudNDepth "
"Conv\" node as the input."
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:364
msgid ""
"The display on the left window enters Interactor mode. Use mouse to "
"carefully select the region that contains the desired model."
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:368
msgid "Run the Mod Finder node. One object is found."
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:372
msgid ""
"The default value of “Total Occurrences” is one. Set it to all to detect "
"all the object."
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:376
msgid "Run the Mod Finder node. Three objects are found."
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:380
msgid "Open the Model Parameter Configurator. Set the \"Acceptance\" to low."
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:386
msgid "Run the Mod Finder node again. All of the objects are found."
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:389
msgid "General process of Using Mod Finder Node"
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:391
msgid ""
"Link input model image. For 3d mod finder node, the input must be the "
"output of DA CloudNDepthConv Node."
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:392
msgid "Run node once so the input image shows on the display."
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:393
msgid ""
"Define model, click on \"+\" button to add a model, and draw a bounding "
"box in the input image to define the model."
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:394
msgid "(Optional) adjust model in the model config page."
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:395
msgid ""
"Run the node with other images. The found occurrences of the model will "
"be displayed in the target image."
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:396
msgid ""
"Use the position vector  for further processing to get the picking pose "
"of the objects in the scene."
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:401
msgid "Model Masking"
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:402
msgid ""
"The model in this node is edgel model. Edge model use their edge-based "
"geometric features (geometric features from extracted edges) to find the "
"position of object."
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:406
msgid "The model is defined by drawing a rectangle box on display."
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:412
msgid ""
"You may draw mask on the model to erase unwanted edges. After draw mask, "
"run this node to apply changes"
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:420
msgid "The model can be searched on image."
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:439
msgid "Search Model In Labelled Mask Sequence"
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:441
msgid ""
"This is a special use case of mod finder where the input is the result of"
" segmentation (a vector of image, each contains an object) instead of a "
"single image."
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:443
msgid "Use DL segmentation node to obtain segments and their labels."
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:444
msgid "In mod finder node, define models. Assign correct labels to the models."
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:445
msgid ""
"Check \"Use Labelled Mask Sequence\", and link the labelled mask sequence"
" to mask sequence output of of the DL segmentation node."
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:446
msgid ""
"Run the node. For each mask image in the sequence the node will search "
"for the model based on the model of the mask image (label of the "
"segment)."
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:447
msgid ""
"The result pose (sorted in labelledPose2dSequence or "
"labelledPose3dSequence) will have the same order of the segments vector "
"of the DL segmentation node."
msgstr ""

#: ../nodes/DA Finder Modules/Mod Modules/measurement_overview.rst:8
#: Modules/metrology_overview.rst:5 Modules/shape_finder_overview.rst:5
#: Node.rst:451
msgid "Reference Fixture"
msgstr ""

#: ../nodes/DA Finder Modules/Mod Node.rst:452
msgid "Please refer to Reference Fixture System."
msgstr ""

#: ../nodes/DA Finder Modules/Mod Modules/shape_finder_overview.rst:9
#: Node.rst:454
msgid "This node can be used for generating fixture."
msgstr ""

#: ../nodes/DA 3D Modules/Mono Node.rst:2
msgid "Mono 3D Node"
msgstr ""

#: ../nodes/DA 3D Modules/Mono Node.rst:5
msgid "Estimate 3d pose of object from 2d image."
msgstr ""

#: ../nodes/DA Fixture Modules/Reference System.rst:2
msgid "Reference Fixture System"
msgstr ""

#: ../nodes/DA ../nodes/Flowchart_control/Condition
#: ../nodes/Flowchart_control/Constant ../nodes/Flowchart_control/Continue
#: ../nodes/Flowchart_control/Flowchart ../nodes/Flowchart_control/Halt
#: ../nodes/Flowchart_control/Loop ../nodes/Flowchart_control/Switch Fixture
#: Modules/Reference Node.rst:5 System.rst:5
msgid "Synopsis"
msgstr ""

#: ../nodes/DA Fixture Modules/Reference System.rst:6
msgid ""
"Fixture system allows you to define a reference frame and make all other "
"things relative to the fixture frame."
msgstr ""

#: ../nodes/DA Fixture Modules/Reference System.rst:10
msgid "Define Fixture"
msgstr ""

#: ../nodes/DA Fixture Modules/Reference System.rst:11
msgid ""
"The fixture is defined in a 2d mod finder or 3d mod finder node. It is "
"recommend to have only one model in this node. If more than 1 model "
"defined, it will pick the one with highest score."
msgstr ""

#: ../nodes/DA Fixture Modules/Reference System.rst:14
msgid ""
"For example, we define model as following. The model will generate a "
"reference frame, and the reference frame changes along with detected "
"obect."
msgstr ""

#: ../nodes/DA Fixture Modules/Reference System.rst:22
msgid "Use Fixture"
msgstr ""

#: ../nodes/DA Fixture Modules/Reference System.rst:23
msgid ""
"After you clicked the checkbox of use_fixture in a node, you can select a"
" mod_finder node as reference."
msgstr ""

#: ../nodes/DA Fixture Modules/Reference System.rst:25
msgid ""
"For shape_finder node and mod_finder node, you need to redefine search "
"region for each model. The region redefine should be done on the same "
"image of reference mod_finder node."
msgstr ""

#: ../nodes/DA Fixture Modules/Reference System.rst:27
msgid ""
"For measurement node and metrology node, you need to relocate or redefine"
" the search region, as their position will change with the fixture."
msgstr ""

#: ../nodes/DA Fixture Modules/Reference System.rst:29
msgid ""
"Following images are metrology node without fixture. The blue region is "
"the search region for searching circle."
msgstr ""

#: ../nodes/DA Fixture Modules/Reference System.rst:36
msgid ""
"Following images are metrology node with fixture. The search region "
"changes with the fixture."
msgstr ""

#: ../nodes/DA Fixture Modules/Reference System.rst:43
msgid ""
"Following images are mod_finder node with fixture. The yellow box is the "
"fixture object, and the blue box is the search region that changes with "
"the fixture."
msgstr ""

#: ../nodes/DA Finder Modules/Shape Node.rst:2
msgid "Shape Finder Node"
msgstr ""

#: ../nodes/DA Finder Modules/Shape Node.rst:5
msgid "Search shape on gray image using edge based searching."
msgstr ""

#: ../nodes/DA Modules/code_reader_overview.rst:4
msgid ""
"This node reads in an image, then detect the code on the image. The input"
" will be considered as an gray image. The node can read 1d code or 2d "
"codes base on node setting, such as:"
msgstr ""

#: ../nodes/DA Modules/code_reader_overview.rst:8
msgid "code type"
msgstr ""

#: ../nodes/DA Modules/code_reader_overview.rst:9
msgid "detect code amount"
msgstr ""

#: ../nodes/DA Modules/code_reader_overview.rst:10
msgid "search region"
msgstr ""

#: ../nodes/DA Modules/code_reader_overview.rst:12
msgid "The output contains the information of the node, include:"
msgstr ""

#: ../nodes/DA Modules/code_reader_overview.rst:14
msgid "the code string"
msgstr ""

#: ../nodes/DA Modules/code_reader_overview.rst:15
msgid "the position of code"
msgstr ""

#: ../nodes/DA Modules/code_reader_overview.rst:18
#: Modules/color_checker_overview.rst:12
msgid "Use Case"
msgstr ""

#: ../nodes/DA Modules/code_reader_overview.rst:19
msgid "When we want to read code on object to distinguish them."
msgstr ""

#: ../nodes/DA Modules/code_reader_overview.rst:24
msgid ""
"Image_In: (DataType:BPImage) The image with code on it. If the input is a"
" color image, the node will consider it as a gray image."
msgstr ""

#: ../nodes/DA Modules/code_reader_overview.rst:26
msgid ""
"Num_to_Detect: the number of code to detect. Note Only 1D code types "
"(excluding GS1 Databar, 4-state, Planet, and Postnet code types) and the "
"2D Data Matrix code type support searching for multiple occurrences."
msgstr ""

#: ../nodes/DA Modules/code_reader_overview.rst:28
msgid "Code_Type: The type(format) of code to be detect"
msgstr ""

#: ../nodes/DA Modules/code_reader_overview.rst:32
#: Modules/color_checker_overview.rst:35
msgid "Advance Settings"
msgstr ""

#: ../nodes/DA Modules/code_reader_overview.rst:35
msgid "foreground_color:"
msgstr ""

#: ../nodes/DA Modules/code_reader_overview.rst:36
msgid "Sets the foreground color of the code."
msgstr ""

#: ../nodes/DA Modules/code_reader_overview.rst:37
msgid "threshold_mode:"
msgstr ""

#: ../nodes/DA Modules/code_reader_overview.rst:38
msgid "Sets the threshold mode used to internally binarize the source image"
msgstr ""

#: ../nodes/DA Modules/code_reader_overview.rst:41
msgid "threshold_value:"
msgstr ""

#: ../nodes/DA Modules/code_reader_overview.rst:40
msgid "range [0, 255]"
msgstr ""

#: ../nodes/DA Modules/code_reader_overview.rst:42
msgid ""
"Sets the threshold value used to internally binarize the source image, "
"depending on the specified threshold mode. Note that if THRESHOLD_MODE is"
" set to ADAPTIVE, this control type is ignored"
msgstr ""

#: ../nodes/DA Modules/code_reader_overview.rst:45
msgid "minimum_contrast:"
msgstr ""

#: ../nodes/DA Modules/code_reader_overview.rst:44
msgid "range [1, 255]"
msgstr ""

#: ../nodes/DA Modules/code_reader_overview.rst:46
msgid ""
"Sets the minimum possible contrast between the foreground and background "
"in the target image for 1D codes (excluding Planet and Postnet) when "
"using the ADAPTIVE threshold mode. Increasing the minimum contrast will "
"typically improve code detection, particularly in the presence of noise "
"and non-uniform lighting.However, if the minimum contrast is higher than "
"the contrast of a code, the code will not be read correctly.For 2D codes,"
" the minimum contrast is determined automatically, so the adaptive "
"threshold mode does not use the minimum_contrast setting."
msgstr ""

#: ../nodes/DA Modules/code_reader_overview.rst:47
msgid "speed:"
msgstr ""

#: ../nodes/DA Modules/code_reader_overview.rst:48
msgid ""
"Sets the search speed. The faster the search speed, the less robust the "
"operation. For 1D code types, consider reducing the search speed when the"
" pixel height of the bar code is small.For 2D code types, consider "
"reducing the search speed when the cell size is small relative to the "
"image size."
msgstr ""

#: ../nodes/DA Modules/code_reader_overview.rst:49
msgid "time_out:"
msgstr ""

#: ../nodes/DA Modules/code_reader_overview.rst:50
msgid ""
"Specifies the maximum decoding time for an detection, in msec. default is"
" 2000."
msgstr ""

#: ../nodes/DA Modules/code_reader_overview.rst:54
msgid "error_correction:"
msgstr ""

#: ../nodes/DA Modules/code_reader_overview.rst:52
msgid ""
"Sets the type of error correction. This field will change base on "
"different code type."
msgstr ""

#: ../nodes/DA Modules/code_reader_overview.rst:54
msgid "Only 2D Aztec code type support percentage correction. Range [5, 95]"
msgstr ""

#: ../nodes/DA Modules/code_reader_overview.rst:56
msgid "check_quiet_zone:"
msgstr ""

#: ../nodes/DA Modules/code_reader_overview.rst:57
msgid ""
"Sets whether the presence of the quiet zone is necessary for a successful"
" detection of this code type."
msgstr ""

#: ../nodes/DA Modules/code_reader_overview.rst:58
msgid "string_format:"
msgstr ""

#: ../nodes/DA Modules/code_reader_overview.rst:59
msgid "Sets the format of the output of the string."
msgstr ""

#: ../nodes/DA Modules/code_reader_overview.rst:62
msgid "search_angle_value:"
msgstr ""

#: ../nodes/DA Modules/code_reader_overview.rst:61
msgid "range [0, 360]"
msgstr ""

#: ../nodes/DA Modules/code_reader_overview.rst:63
msgid "Sets the nominal search angle. default is 0."
msgstr ""

#: ../nodes/DA Modules/code_reader_overview.rst:66
msgid "search_angle_step:"
msgstr ""

#: ../nodes/DA Modules/code_reader_overview.rst:65
msgid "range [0.1, 180.0]"
msgstr ""

#: ../nodes/DA Modules/code_reader_overview.rst:67
msgid ""
"Sets the angle increment/decrement used when searching for a 1D code "
"through an angular range."
msgstr ""

#: ../nodes/DA Modules/code_reader_overview.rst:68
msgid "search_angle_delta_neg:"
msgstr ""

#: ../nodes/DA Modules/code_reader_overview.rst:69
msgid "Sets the negative angular range of the search."
msgstr ""

#: ../nodes/DA Modules/code_reader_overview.rst:72
msgid "search_angle_delta_pos:"
msgstr ""

#: ../nodes/DA Modules/code_reader_overview.rst:71
msgid "Sets the positive angular range of the search."
msgstr ""

#: ../nodes/DA Modules/code_reader_overview.rst:77
msgid ""
"result: (DataType: CodeReaderResult) The result of code reader, "
"containing the information of the code."
msgstr ""

#: ../nodes/DA Modules/code_reader_overview.rst:77
msgid ""
"decodedString: (DataType: Vector<String>) A vector of string, each "
"contains the plaintext of a found code."
msgstr ""

#: ../nodes/DA Modules/code_reader_overview.rst:79
msgid "numCodeDetect: (DataType: Int) The number of code detected"
msgstr ""

#: ../nodes/DA Modules/code_reader_procedure.rst:2
msgid "Procedure of Using Code Reader Node"
msgstr ""

#: ../nodes/DA Modules/code_reader_procedure.rst:4
msgid ""
"(If needed) convert input image from RGB to gray scale using image "
"process node."
msgstr ""

#: ../nodes/DA Modules/code_reader_procedure.rst:5
msgid ""
"Link \"Image In\" field to the gray scale image. Run the node once. You "
"will see the original image on the display."
msgstr ""

#: ../nodes/DA Modules/code_reader_procedure.rst:6
msgid ""
"Select the code type and number of occurrences to find. Optionally, "
"define a search region on the image by clicking on \"Define Search "
"Region\" button and draw a rectangle ROI on display."
msgstr ""

#: ../nodes/DA Modules/code_reader_procedure.rst:7
msgid ""
"Run the node again. Now you should see the found code region with the "
"decoded string in the middle."
msgstr ""

#: ../nodes/DA Modules/code_reader_procedure.rst:8
msgid ""
"Optionally, adjust advanced parameters to get better result. See the "
"definition of advanced parameters in overview page."
msgstr ""

#: ../nodes/DA Modules/code_reader_procedure.rst:9
msgid ""
"Use the decoded string to define further picking action. For example, run"
" different flowchart branch based on the string from the code."
msgstr ""

#: ../nodes/DA Modules/color_checker_overview.rst:4
msgid "The node supports two modes."
msgstr ""

#: ../nodes/DA Modules/color_checker_overview.rst:6
msgid "Color Matching:"
msgstr ""

#: ../nodes/DA Modules/color_checker_overview.rst:7
msgid "match defined region with its nearest defined color"
msgstr ""

#: ../nodes/DA Modules/color_checker_overview.rst:9
msgid "Color Segmentation:"
msgstr ""

#: ../nodes/DA Modules/color_checker_overview.rst:9
msgid "Segment Image with defined color"
msgstr ""

#: ../nodes/DA Modules/color_checker_overview.rst:13
msgid "When we want to use color on similar objects to distinguish them."
msgstr ""

#: ../nodes/DA Modules/color_checker_overview.rst:17
msgid "Color Image In: (DataType: Image) A color image."
msgstr ""

#: ../nodes/DA Modules/color_checker_overview.rst:20
msgid "Color Function:"
msgstr ""

#: ../nodes/DA Modules/color_checker_overview.rst:20
msgid ""
"decide whether you want to use Color_Matching function or Color "
"Segmentation function."
msgstr ""

#: ../nodes/DA Modules/color_checker_overview.rst:24
msgid "Tolerance:"
msgstr ""

#: ../nodes/DA Modules/color_checker_overview.rst:23
#: Modules/color_checker_overview.rst:27
msgid "Range [0 ~ 100]"
msgstr ""

#: ../nodes/DA Modules/color_checker_overview.rst:25
msgid ""
"The global tolerance for color_samples. if you set this to 100, the "
"tolerance will become infinite. default is 100."
msgstr ""

#: ../nodes/DA Modules/color_checker_overview.rst:32
msgid "Confidence:"
msgstr ""

#: ../nodes/DA Modules/color_checker_overview.rst:29
msgid ""
"Represents how confident you can be that the best-matched color-sample "
"actually is the best possible match."
msgstr ""

#: ../nodes/DA Modules/color_checker_overview.rst:31
msgid ""
"For example, a high confidence indicates that the best-matched color-"
"sample must be vastly superior to all other color-samples, while a low "
"confidence indicates that the best-matched color-sample only needs to be "
"marginally superior to the other color-samples."
msgstr ""

#: ../nodes/DA Modules/color_checker_overview.rst:36
msgid "Color Space:"
msgstr ""

#: ../nodes/DA Modules/color_checker_overview.rst:37
msgid "Specifies the conversion mode that the operation uses."
msgstr ""

#: ../nodes/DA Modules/color_checker_overview.rst:38
msgid "Match Distance:"
msgstr ""

#: ../nodes/DA Modules/color_checker_overview.rst:39
msgid ""
"Specifies the type of distance that the operation uses. Distance is the "
"difference in color between the color-sample and the target area."
msgstr ""

#: ../nodes/DA Modules/color_checker_overview.rst:40
msgid "Match Method:"
msgstr ""

#: ../nodes/DA Modules/color_checker_overview.rst:41
msgid "Specifies the function used to match distance."
msgstr ""

#: ../nodes/DA Modules/color_checker_overview.rst:42
msgid "Tolerance Mode:"
msgstr ""

#: ../nodes/DA Modules/color_checker_overview.rst:43
msgid ""
"Sets the strategy with which to use the tolerance value to calculate the "
"acceptable (matching) color distance (tolerance) between the color-sample"
" and a target area."
msgstr ""

#: ../nodes/DA Modules/color_checker_overview.rst:47
msgid "Global Tolerance:"
msgstr ""

#: ../nodes/DA Modules/color_checker_overview.rst:45
msgid "range [0.0, ~)"
msgstr ""

#: ../nodes/DA Modules/color_checker_overview.rst:47
msgid ""
"Sets the acceptable tolerance for the color distance between the color-"
"sample and a target area. The greater the tolerance, the greater the "
"distance (difference) between the colors can be, for them to match."
msgstr ""

#: ../nodes/DA Modules/color_checker_overview.rst:51
msgid "Minimum Score:"
msgstr ""

#: ../nodes/DA Modules/color_checker_overview.rst:50
#: Modules/color_checker_overview.rst:54
msgid "range [0.0, 100.0]"
msgstr ""

#: ../nodes/DA Modules/color_checker_overview.rst:52
msgid ""
"Sets the acceptance level for the color-sample's score. This score "
"indicates the similarity between the color of the color-sample and the "
"color of the target area. The higher the acceptance, the closer the "
"colors must be for them to match.For a match, the color-sample must have "
"a score that is greater than or equal to this level."
msgstr ""

#: ../nodes/DA Modules/color_checker_overview.rst:58
msgid "Minimum Relative Score:"
msgstr ""

#: ../nodes/DA Modules/color_checker_overview.rst:56
msgid ""
"Sets the acceptance level for the target area's relevance score. This "
"score indicates the significance (relevance) of the match score. In "
"statistics, this is similar to the confidence level; that is, it "
"represents how confident you can be that the best-matched color-sample "
"actually is the best possible match."
msgstr ""

#: ../nodes/DA Modules/color_checker_overview.rst:58
msgid ""
"For example, a high relevance acceptance indicates that the best-matched "
"color-sample must be vastly superior to all other color-samples, while a "
"low relevance acceptance indicates that the best-matched color-sample "
"only needs to be marginally superior to the other color-samples."
msgstr ""

#: ../nodes/DA Modules/color_checker_overview.rst:62
msgid ""
"result: (DataType: ColorCheckerResult) Color Checker Output. So far this "
"output is not used."
msgstr ""

#: ../nodes/DA Modules/color_checker_procedure.rst:2
msgid "Procedure of Using Color Checker Node"
msgstr ""

#: ../nodes/DA Modules/color_checker_procedure.rst:4
msgid "Link input image."
msgstr ""

#: ../nodes/DA Modules/color_checker_procedure.rst:5
msgid "2. Define search region. 1. Define Color. 2."
msgstr ""

#: ../nodes/DA Modules/color_checker_procedure.rst:11
msgid "Define Region"
msgstr ""

#: ../nodes/DA Modules/color_checker_procedure.rst:12
msgid ""
"In color segmentation, node will consider all defined region as a single "
"combined region. In color matching, node will match each defined region "
"to the nearest color sample."
msgstr ""

#: ../nodes/DA Modules/color_checker_procedure.rst:15
msgid "There is 3 way for defining a region:"
msgstr ""

#: ../nodes/DA Modules/color_checker_procedure.rst:18
msgid "Use Image Mask."
msgstr ""

#: ../nodes/DA Modules/color_checker_procedure.rst:18
msgid ""
"Input a Image Mask that has same size as Color Image. Node will define "
"only one single region base on the mask."
msgstr ""

#: ../nodes/DA Modules/color_checker_procedure.rst:23
msgid "Define from mod finder node"
msgstr ""

#: ../nodes/DA Modules/color_checker_procedure.rst:21
msgid ""
"Input a Mod Finder Result comes from mod_finder node Select one model in "
"Mod Finder Result. One region will be defined for each object found from "
"mod_finder. Draw mask on model to define the color match region related "
"to object"
msgstr ""

#: ../nodes/DA Modules/color_checker_procedure.rst:28
msgid "Define from display"
msgstr ""

#: ../nodes/DA Modules/color_checker_procedure.rst:26
msgid "Draw a rectangle box from main display Draw mask for this region"
msgstr ""

#: ../nodes/DA Modules/color_checker_procedure.rst:31
msgid "Color Sample"
msgstr ""

#: ../nodes/DA Modules/color_checker_procedure.rst:32
msgid "The node will only match regions to defined color"
msgstr ""

#: ../nodes/DA Modules/color_checker_procedure.rst:34
msgid "There are 2 ways to define a color sample"
msgstr ""

#: ../nodes/DA Modules/color_checker_procedure.rst:37
msgid "Define color by area."
msgstr ""

#: ../nodes/DA Modules/color_checker_procedure.rst:37
msgid ""
"Draw a box on display, node will calculate the average color of this box,"
" and save it as color sample value. Additionally, you can draw/erase mask"
" to change pixels included when calculate average."
msgstr ""

#: ../nodes/DA Modules/color_checker_procedure.rst:40
msgid "Define color by value"
msgstr ""

#: ../nodes/DA Modules/color_checker_procedure.rst:40
msgid ""
"Define a RGB value as color sample. The color can be set from a color "
"board, manually set HSV or RGB value, or pick a pixel's color from the "
"screen."
msgstr ""

#: ../nodes/DA Modules/da_alignment_overview.rst:6
msgid ""
"Scene Cloud: (DataType: Cloud)Scene point cloud. Model Cloud: (DataType: "
"Cloud)Model point cloud. Hypothesis: (DataType: Pose)The initial guess "
"for the pose, usually obtained from reconstruct node."
msgstr ""

#: ../nodes/DA Modules/da_alignment_overview.rst:12
msgid "poses: (DataType: Pose)The aligned poses, a vector of 3D pose."
msgstr ""

#: ../nodes/DA Modules/da_alignment_procedure.rst:2
msgid "Procedure of Using DA Alignment Node"
msgstr ""

#: ../nodes/DA Modules/da_alignment_procedure.rst:4
msgid "Input Scene Cloud, a point cloud of scene."
msgstr ""

#: ../nodes/DA Modules/da_alignment_procedure.rst:5
msgid ""
"This can be obtained from camera node, and be cropped by cloud process "
"node."
msgstr ""

#: ../nodes/DA Modules/da_alignment_procedure.rst:6
msgid "Input Model Cloud, a point cloud of object model."
msgstr ""

#: ../nodes/DA Modules/da_alignment_procedure.rst:7
msgid ""
"The model point cloud is better to be saved int file, and loaded from "
"reader node."
msgstr ""

#: ../nodes/DA Modules/da_alignment_procedure.rst:8
msgid "Input Hypothesis, the initial guess of objects."
msgstr ""

#: ../nodes/DA Modules/da_alignment_procedure.rst:9
msgid ""
"This input is a vector of poses, usually is obtained from reconstruct "
"node."
msgstr ""

#: ../nodes/DA Modules/da_alignment_procedure.rst:10
msgid ""
"Run the node, you can check the display result to check if the alignment "
"is good or bad."
msgstr ""

#: ../nodes/DA Modules/da_alignment_procedure.rst:11
msgid "The Node will output the aligned poses."
msgstr ""

#: ../nodes/DA Modules/da_alignment_procedure.rst:19
#: Modules/shape_finder_procedure.rst:12
msgid "Parameter Tunning"
msgstr ""

#: ../nodes/DA Modules/da_alignment_procedure.rst:20
msgid "Use Model Box:"
msgstr ""

#: ../nodes/DA Modules/da_alignment_procedure.rst:21
msgid ""
"Specifies whether to use the model point cloud's extraction box to limit "
"the points during alignment."
msgstr ""

#: ../nodes/DA Modules/da_alignment_procedure.rst:29
msgid "Error Metric:"
msgstr ""

#: ../nodes/DA Modules/da_alignment_procedure.rst:23
msgid ""
"Specifies the technique that the alignment algorithm uses to minimize the"
" RMS error."
msgstr ""

#: ../nodes/DA Modules/da_alignment_procedure.rst:25
msgid ""
"\"POINT_TO_POINT\" specifies that the technique minimizes the Euclidean "
"distance between the points in the model and scene point clouds, with no "
"special consideration to the normals to the surface of the point clouds."
msgstr ""

#: ../nodes/DA Modules/da_alignment_procedure.rst:27
msgid ""
"\"POINT_TO_PLANE + USE_SCENE_NORMALS\" specifies to measure the distance "
"between the tangent planes of the surface of the scene point cloud "
"(calculated from the scene normals) and the points of the model point "
"cloud."
msgstr ""

#: ../nodes/DA Modules/da_alignment_procedure.rst:29
msgid ""
"\"POINT_TO_PLANE + USE_MODEL_NORMALS\" Specifies to measure the distance "
"between the tangent planes of the surface of the model point cloud "
"(calculated from the model normals) and the points of the scene point "
"cloud. It can be beneficial to use the normals of the model point cloud "
"when the model point cloud has fewer points than the scene point cloud, "
"because fewer normals need to be calculated."
msgstr ""

#: ../nodes/DA Modules/da_alignment_procedure.rst:39
msgid "Max Iterations:"
msgstr ""

#: ../nodes/DA Modules/da_alignment_procedure.rst:32
msgid ""
"the maximum iteration to stop. Fewer iteration will decrease accuracy and"
" limit the running time."
msgstr ""

#: ../nodes/DA Modules/da_alignment_procedure.rst:34
msgid "DEFAULT: 20"
msgstr ""

#: ../nodes/DA Modules/da_alignment_procedure.rst:35
msgid "VERY LOW: 5"
msgstr ""

#: ../nodes/DA Modules/da_alignment_procedure.rst:36
msgid "LOW: 15"
msgstr ""

#: ../nodes/DA Modules/da_alignment_procedure.rst:37
msgid "MEDIUM: 50"
msgstr ""

#: ../nodes/DA Modules/da_alignment_procedure.rst:38
msgid "HIGH: 100"
msgstr ""

#: ../nodes/DA Modules/da_alignment_procedure.rst:39
msgid "VERY HIGH: 200"
msgstr ""

#: ../nodes/DA Modules/da_alignment_procedure.rst:48
msgid "Model Overlap:"
msgstr ""

#: ../nodes/DA Modules/da_alignment_procedure.rst:42
msgid "Range [1, 100]."
msgstr ""

#: ../nodes/DA Modules/da_alignment_procedure.rst:44
msgid ""
"Controls the percentage of model points used to pair with scene points "
"during the alignment process."
msgstr ""

#: ../nodes/DA Modules/da_alignment_procedure.rst:46
msgid "MEDIUM (DEFAULT): 50"
msgstr ""

#: ../nodes/DA Modules/da_alignment_procedure.rst:47
msgid "HIGH: 77"
msgstr ""

#: ../nodes/DA Modules/da_alignment_procedure.rst:48
msgid "VERY HIGH: 97"
msgstr ""

#: ../nodes/DA Modules/da_alignment_procedure.rst:57
msgid "Down Sample Strength:"
msgstr ""

#: ../nodes/DA Modules/da_alignment_procedure.rst:51
msgid "Range [1, 10]."
msgstr ""

#: ../nodes/DA Modules/da_alignment_procedure.rst:53
msgid ""
"Controls overall downsample intensity for the scene and model. Larger "
"values mean stronger downsample."
msgstr ""

#: ../nodes/DA Modules/da_alignment_procedure.rst:55
msgid "LOW: 2"
msgstr ""

#: ../nodes/DA Modules/da_alignment_procedure.rst:56
msgid "MEDIUM (DEFAULT): 4"
msgstr ""

#: ../nodes/DA Modules/da_alignment_procedure.rst:57
msgid "HIGH: 8"
msgstr ""

#: ../nodes/DA Modules/da_alignment_procedure.rst:60
msgid "Decimation Step Model:"
msgstr ""

#: ../nodes/DA Modules/da_alignment_procedure.rst:60
msgid "Step size used when downsampling the model."
msgstr ""

#: ../nodes/DA Modules/da_alignment_procedure.rst:62
msgid "Decimation Step Scene:"
msgstr ""

#: ../nodes/DA Modules/da_alignment_procedure.rst:63
msgid "Step size used when downsampling the scene."
msgstr ""

#: ../nodes/DA Modules/da_calibration_overview.rst:9
msgid ""
"Load : In this mode, the calibration node loads the ouput from the final "
"for future use. This can help to load previous calibration results "
"without a need to run previous modes."
msgstr ""

#: ../nodes/DA Modules/da_calibration_overview.rst:15
#: Modules/da_calibration_overview.rst:33
#: Modules/da_calibration_overview.rst:50
msgid ""
"Hand Eye Confg (type:Int) : Robot camera configuration. Either eye-to-"
"hand (calibration tool mounted on robot) or eye-in-hand (camera mounted "
"on robot)."
msgstr ""

#: ../nodes/DA Modules/da_calibration_overview.rst:27
#: Modules/da_calibration_overview.rst:44
msgid ""
"milCalibrationID (type:MIL_ID) : This output includes the information "
"about the calibration settings alongside with the data needed for "
"performing calibration computation in the final mode."
msgstr ""

#: ../nodes/DA Modules/da_calibration_overview.rst:28
#: Modules/da_calibration_overview.rst:45
msgid ""
"calibrationStatus (type:Int) : This output indicates if there were any "
"errors during the node execution. If the value is 0, no error has "
"occurred. However, if the value is non-zero, an error has occurred during"
" execution and an error message will be printed in the console."
msgstr ""

#: ../nodes/DA Modules/da_calibration_overview.rst:35
msgid ""
"File name (type:String) : The filename used to save the outputs of the "
"node in. This file is saved in the folder 'da_calibrations' in the "
"workspace folder."
msgstr ""

#: ../nodes/DA Modules/da_calibration_overview.rst:40
msgid ""
"cam_in_gripper (type:Pose) : The 3D transformation from the camera to the"
" gripper (TCP). Only has value in eye-in-hand situations."
msgstr ""

#: ../nodes/DA Modules/da_calibration_overview.rst:41
msgid ""
"base_in_world (type:Pose) : The 3D transformation from robot base to the "
"world (calibration board). Only has value in eye-in-hand situations."
msgstr ""

#: ../nodes/DA Modules/da_calibration_procedure.rst:3
msgid "Procedure of Using DA Calibration Node"
msgstr ""

#: ../nodes/DA Modules/da_calibration_procedure.rst:17
msgid ""
"Note that the captured images should contain a variety of images with "
"different position and rotation angles to ensure a good calibration "
"result. Once you have captured calibration images, you can add the "
"calibration node into the flowchart to perform calibration. (Templates "
"provided in the software) When adding this node to the flowchart, you "
"will see the option for choosing the calibration mode. We provide three "
"modes for the calibration node. First, the accumulation mode is used to "
"load the captured images, poses and point clouds from the calibration "
"board and detect the corner points (chessboard) or circle center points "
"(circle board). When you choose the accumulation mode, you will be able "
"to set different options and inputs."
msgstr ""

#: ../nodes/DA Modules/da_calibration_procedure.rst:31
msgid ""
"As shown in the above image, you have to choose the hand-eye "
"configuration. Also, the other inputs include the captured image, robot "
"pose (base in gripper) for each robot position. In addition, you have to "
"choose the used grid board type (calibration tool). Note that you can see"
" the result of the accumulation node (detected points) by clicking on the"
" node. In case the algorithm is not able to detect the corner/circle "
"points, the image will be skipped and not used for final calibration."
msgstr ""

#: ../nodes/DA Modules/da_calibration_procedure.rst:42
msgid ""
"In the final node, you have to specify the reference accumulation node, "
"so, the results then can be used for calibration. Also, as the "
"calibration algorithm will use an optimization based method to obtain the"
" calibration results, you need to choose the used cost function. In case "
"of using a 3D camera and 3D picking, it is a better option to use the "
"RPDepth cost function as our experiments show better results for this "
"cost function. However, note that when using RPDepth, you will need to "
"set the option \"using the point cloud\" in the accumulation mode. By "
"running the calibration node in the final mode, the calibration results "
"will be obtained. More specifically, the main outputs of the final mode "
"are the camera to gripper and base to board 3D transformations in the "
"eye-in-hand scenario. This will be camera to base and gripper to board 3D"
" transformations in the eye-to-hand scenario. These transformations then "
"can be used in the picking flowchart for different robot picking "
"operations."
msgstr ""

#: ../nodes/DA Modules/da_cloudndepth_overview.rst:7
msgid ""
"Depth Map (DataType: DepthImage) The input depth map. Used in depth to "
"cloud mode;"
msgstr ""

#: ../nodes/DA Modules/da_cloudndepth_overview.rst:8
msgid "PointCloud : the input point cloud. Used in cloud to depth mode;"
msgstr ""

#: ../nodes/DA Modules/da_cloudndepth_overview.rst:9
msgid "Depthmap Size X,Y For Cloud to Depth, set the size of depth image."
msgstr ""

#: ../nodes/DA Modules/da_cloudndepth_overview.rst:13
msgid "Extraction Box Settings"
msgstr ""

#: ../nodes/DA Modules/da_cloudndepth_overview.rst:11
msgid ""
"For Cloud to Depth, set the extraction box. Only points inside the box "
"will be extracted into depth map. Normally these parameters are tunned by"
" adjust box on interactive display when running the node."
msgstr ""

#: ../nodes/DA Modules/da_cloudndepth_overview.rst:18
msgid "Depth Map -> Point Cloud:"
msgstr ""

#: ../nodes/DA Modules/da_cloudndepth_overview.rst:18
msgid ""
"For each pixel point in depth image, generate a point with its depth "
"value and add it into point cloud."
msgstr ""

#: ../nodes/DA Modules/da_cloudndepth_overview.rst:24
msgid "Point Cloud -> Depth Map:"
msgstr ""

#: ../nodes/DA Modules/da_cloudndepth_overview.rst:21
msgid ""
"You set the size_x and size_y of depth image. From point cloud, draw a "
"box in point cloud. For all the points in the box, select the top points "
"and put it as pixel points of depth image. Then remap the depth image to "
"a size_x,size_y depth image."
msgstr ""

#: ../nodes/DA Modules/da_cloudndepth_overview.rst:30
msgid "Generated Point Cloud (DataType: Cloud) Output of Depth to Cloud"
msgstr ""

#: ../nodes/DA Modules/da_cloudndepth_overview.rst:31
msgid "Generated Depth Map (DataType: DepthImage) Output of Cloud to Depth."
msgstr ""

#: ../nodes/DA Modules/da_cloudndepth_overview.rst:32
msgid ""
"Generated 8bit Depth Map (DataType: DepthImage) Output of Cloud to Depth."
" This image is 8bit image so it can be considered as a gray scale image."
msgstr ""

#: ../nodes/DA Modules/da_cloudndepth_procedure.rst:2
msgid "Procedure of Using DA CloudNDepth Conv Node"
msgstr ""

#: ../nodes/DA Modules/da_cloudndepth_procedure.rst:4
msgid "Link point cloud from camera node or reader node."
msgstr ""

#: ../nodes/DA Modules/da_cloudndepth_procedure.rst:5
msgid "Change size of the depth image. Run the node."
msgstr ""

#: ../nodes/DA Modules/da_cloudndepth_procedure.rst:6
msgid "Draw a bounding box to cover the points to be converted."
msgstr ""

#: ../nodes/DA Modules/da_cloudndepth_procedure.rst:7
msgid ""
"Now we have the depth image, 8 bit depth image output. The node's result "
"can be used as input for Mod Finder node in 3d mode."
msgstr ""

#: ../nodes/DA Modules/da_cloudndepth_procedure.rst:8
msgid ""
"The depth to cloud mode takes in the output of cloud to depth mode. It "
"can restore the point cloud from depth image."
msgstr ""

#: ../nodes/DA Modules/index.rst:2
msgid "DaoAI Advanced Modules"
msgstr ""

#: ../nodes/DA Modules/measurement_detail.rst:2
msgid "Marker Parameter Tunning"
msgstr ""

#: ../nodes/DA Modules/measurement_detail.rst:3
msgid "Number of Occurrences:"
msgstr ""

#: ../nodes/DA Modules/measurement_detail.rst:4
msgid "The number of maximum edge to detect, default is 1."
msgstr ""

#: ../nodes/DA Modules/measurement_detail.rst:11
msgid "Min Occurrences:"
msgstr ""

#: ../nodes/DA Modules/measurement_detail.rst:12
msgid ""
"Minimum number of edge to detect. if detected less edge, then it is a "
"detection fail."
msgstr ""

#: ../nodes/DA Modules/measurement_detail.rst:14
msgid "Polarity:"
msgstr ""

#: ../nodes/DA Modules/measurement_detail.rst:14
msgid ""
"The polarity of edge to detection direction. Positive is from black to "
"white, Negative is from white to black."
msgstr ""

#: ../nodes/DA Modules/measurement_detail.rst:23
msgid "Polarity2:"
msgstr ""

#: ../nodes/DA Modules/measurement_detail.rst:23
msgid ""
"For stripe markers, decide the polarity of the second edge of stripe, "
"related to stripe's first edge."
msgstr ""

#: ../nodes/DA Modules/measurement_detail.rst:37
msgid "Max Association Distance:"
msgstr ""

#: ../nodes/DA Modules/measurement_detail.rst:32
msgid "not range limit, unit is pixel."
msgstr ""

#: ../nodes/DA Modules/measurement_detail.rst:34
msgid ""
"The maximum distance between a marker's edge (either straight or "
"circular) and its associated sub-edges during fit operation."
msgstr ""

#: ../nodes/DA Modules/measurement_detail.rst:36
msgid ""
"For edge and stripe markers, it is measured perpendicular from the fitted"
" edge position, along to the search direction."
msgstr ""

#: ../nodes/DA Modules/measurement_detail.rst:38
msgid ""
"For circle markers, it is measured radially from the fitted circle "
"perimeter"
msgstr ""

#: ../nodes/DA Modules/measurement_detail.rst:41
msgid "Min Edge Value:"
msgstr ""

#: ../nodes/DA Modules/measurement_detail.rst:40
msgid "Range [0, 100]"
msgstr ""

#: ../nodes/DA Modules/measurement_detail.rst:42
msgid ""
"The confidence of edge detection. A high value will ignore edges with "
"weak contrast. Default is 2.0."
msgstr ""

#: ../nodes/DA Modules/measurement_overview.rst:4
msgid ""
"This node allows you to find markers (for example, edges) in an image, "
"based on differences in pixel intensities. Upon finding a marker, the "
"node outputs the marker's spatial reference position and measures "
"features such as its width and angle. You can calculate measurements "
"between two markers, such as the equation of the line that joins them."
msgstr ""

#: ../nodes/DA Modules/measurement_overview.rst:10
#: Modules/metrology_overview.rst:7 Modules/shape_finder_overview.rst:7
msgid "Please refer to Reference Fixture System"
msgstr ""

#: ../nodes/DA Modules/measurement_overview.rst:14
#: Modules/metrology_overview.rst:11
msgid "Interactive Display"
msgstr ""

#: ../nodes/DA Modules/measurement_overview.rst:16
msgid ""
"You may only be able to edit or add markers after click \"Show "
"Interactive Display\""
msgstr ""

#: ../nodes/DA Modules/measurement_overview.rst:20
msgid "Markers"
msgstr ""

#: ../nodes/DA Modules/measurement_overview.rst:22
msgid "You may click \"+\" button to add a new marker."
msgstr ""

#: ../nodes/DA Modules/measurement_overview.rst:27
msgid "Edge Marker:"
msgstr ""

#: ../nodes/DA Modules/measurement_overview.rst:25
msgid ""
"draw a rectangle region, and detect edges in this region the detection is"
" base on pixel value derivative the detection direction is the arrow "
"direction shown on region"
msgstr ""

#: ../nodes/DA Modules/measurement_overview.rst:32
msgid "Circle Marker:"
msgstr ""

#: ../nodes/DA Modules/measurement_overview.rst:30
msgid ""
"draw a circle region, detect circle inside the region the detection is "
"base on detecting edges from center to 8 outer directions the detection "
"direction is from center to outer"
msgstr ""

#: ../nodes/DA Modules/measurement_overview.rst:36
msgid "Stripe Marker:"
msgstr ""

#: ../nodes/DA Modules/measurement_overview.rst:35
msgid ""
"draw a rectangle region, detect stripes(pair of edges) in the region the "
"detection direction is the arrow direction shown on region"
msgstr ""

#: ../nodes/DA Modules/measurement_overview.rst:41
msgid ""
"result: the measurement result, containing the information of markers "
"such as its position, size, and radius for circle."
msgstr ""

#: ../nodes/DA Modules/measurement_procedure.rst:2
msgid "Procedure of Using Measurement Node"
msgstr ""

#: ../nodes/DA Modules/measurement_procedure.rst:4
msgid "Set input Image."
msgstr ""

#: ../nodes/DA Modules/measurement_procedure.rst:5
#: Modules/metrology_procedure.rst:5
msgid "Open interactive display"
msgstr ""

#: ../nodes/DA Modules/measurement_procedure.rst:6
msgid "Define Markers"
msgstr ""

#: ../nodes/DA Modules/measurement_procedure.rst:7
msgid "Run the node."
msgstr ""

#: ../nodes/DA Modules/metrology_overview.rst:13
msgid ""
"You may only be able to edit or add features after click \"Show "
"Interactive Display\""
msgstr ""

#: ../nodes/DA Modules/metrology_overview.rst:18
msgid ""
"allTolerancesPassed: (DataType:Bool) a boolean value indicating if all "
"tolerances are passed"
msgstr ""

#: ../nodes/DA Modules/metrology_overview.rst:20
msgid "numPassedTolerances: (DataType:Int) number of passed tolerance"
msgstr ""

#: ../nodes/DA Modules/metrology_overview.rst:22
msgid "numWarningTolerances: (DataType:Int) number of warning tolerance"
msgstr ""

#: ../nodes/DA Modules/metrology_overview.rst:24
msgid "numFailedTolerances: (DataType:Int) number of fail tolerance"
msgstr ""

#: ../nodes/DA Modules/metrology_overview.rst:26
msgid ""
"toleranceResult/tolerance_name['']: (DataType:Double) the actual value of"
" the tolerance"
msgstr ""

#: ../nodes/DA Modules/metrology_procedure.rst:2
msgid "Procedure of Using Metrology Node"
msgstr ""

#: ../nodes/DA Modules/metrology_procedure.rst:4
msgid "Link input Image."
msgstr ""

#: ../nodes/DA Modules/metrology_procedure.rst:6
msgid "Define Features"
msgstr ""

#: ../nodes/DA Modules/metrology_procedure.rst:7
msgid "Define Tolerances"
msgstr ""

#: ../nodes/DA Modules/metrology_procedure.rst:8
msgid ""
"Run the node, the node will output the tolerance values and tolerance "
"pass/fail"
msgstr ""

#: ../nodes/DA Modules/metrology_procedure.rst:11
msgid "Feature and Tolerance"
msgstr ""

#: ../nodes/DA Modules/metrology_procedure.rst:14
msgid "Features"
msgstr ""

#: ../nodes/DA Modules/metrology_procedure.rst:22
msgid "There are 3 ways for defining a feature:"
msgstr ""

#: ../nodes/DA Modules/metrology_procedure.rst:17
msgid "Parametric Feature:"
msgstr ""

#: ../nodes/DA Modules/metrology_procedure.rst:18
msgid "define fixture in absolute position."
msgstr ""

#: ../nodes/DA Modules/metrology_procedure.rst:19
msgid "Measured Feature:"
msgstr ""

#: ../nodes/DA Modules/metrology_procedure.rst:20
msgid ""
"define a region in absolute position, detect edge features such as "
"segment and circle in the region."
msgstr ""

#: ../nodes/DA Modules/metrology_procedure.rst:22
msgid "Constructed Feature:"
msgstr ""

#: ../nodes/DA Modules/metrology_procedure.rst:22
msgid ""
"define fixture from other features, such as define a mid_point from a "
"segment, or define a circle base on 2 points."
msgstr ""

#: ../nodes/DA Modules/metrology_procedure.rst:24
msgid ""
"After a feature is defined, the feature(or region for measurement "
"features) will appear in the interactive display at position (0,0) you "
"can drag it to proper position."
msgstr ""

#: ../nodes/DA Modules/metrology_procedure.rst:27
msgid ""
"For measured features, the detection direction is shown as arrow on the "
"edge of searching region. Below is an example of having 2 measured "
"circle. the blue ring is search region, and the red circle is detected."
msgstr ""

#: ../nodes/DA Modules/metrology_procedure.rst:36
msgid "Measured Feature Parameters"
msgstr ""

#: ../nodes/DA Modules/metrology_procedure.rst:37
msgid "Threshold:"
msgstr ""

#: ../nodes/DA Modules/metrology_procedure.rst:38
msgid ""
"A high threshold only keeps edge with strong contrast. A low threshold "
"will include fainter edges."
msgstr ""

#: ../nodes/DA Modules/metrology_procedure.rst:41
msgid "Smoothness:"
msgstr ""

#: ../nodes/DA Modules/metrology_procedure.rst:40
msgid "Range [0.0 ~ 100.0]"
msgstr ""

#: ../nodes/DA Modules/metrology_procedure.rst:42
msgid "Strength of the noise reduction filter when detecting edges."
msgstr ""

#: ../nodes/DA Modules/metrology_procedure.rst:43
msgid "Data Angle Tolerance:"
msgstr ""

#: ../nodes/DA Modules/metrology_procedure.rst:44
msgid ""
"Whether edges along a transition are considered is based on the "
"angle(direction) of the transition compared to the scan direction of the "
"search region. This angle tolerance determines the range of accepted "
"angle(direction)."
msgstr ""

#: ../nodes/DA Modules/metrology_procedure.rst:47
msgid "Edge Selection Rank:"
msgstr ""

#: ../nodes/DA Modules/metrology_procedure.rst:46
msgid ""
"Setting rank \"1\" will fit the segment to the edges closest to the "
"beginning of the search box. Setting \"Disable\" will fit to all the "
"edges found in the search-box."
msgstr ""

#: ../nodes/DA Modules/metrology_procedure.rst:50
msgid "Tolerance"
msgstr ""

#: ../nodes/DA Modules/metrology_procedure.rst:52
msgid ""
"Tolerance is a calculation of features. such as the maximum distance "
"between 2 features. You can add tolerance, and set the pass_min, "
"pass_max, warn_min, warn_max for it. Normally, it is:"
msgstr ""

#: ../nodes/DA Modules/metrology_procedure.rst:55
msgid "warning_min < pass_min < pass_max < warning_max"
msgstr ""

#: ../nodes/DA Modules/metrology_procedure.rst:57
msgid ""
"If the value is between pass_min and pass_max, then it is a pass "
"tolerance, if the value is between warning_min and warning_max, then it "
"is a warning tolerance, if the value is outside of warning_min or "
"warning_max, then it is a fail tolerance."
msgstr ""

#: ../nodes/DA Modules/metrology_procedure.rst:61
msgid "Below is an example of measuring the minimum distance of 2 circle feature:"
msgstr ""

#: ../nodes/DA Modules/mono_3d_overview.rst:5
msgid ""
"Mono 3D node has 4 mode, accumulate, final, set_feature, and "
"pose_estimation. Normally, we use (accumulate + final) or set_feature to "
"define object feature positions, and use pose_estimation to estimate pose"
msgstr ""

#: ../nodes/DA Modules/mono_3d_overview.rst:9
msgid "Define Object Features"
msgstr ""

#: ../nodes/DA Modules/mono_3d_overview.rst:11
msgid ""
"Features are some unique pattern on object that is easy to detect. We can"
" construct the object if we know these feature points in 3d. To define "
"the feature positoin, we can use set_feature mode, to direct input the 3d"
" coordinates of feature points related to object origin."
msgstr ""

#: ../nodes/DA Modules/mono_3d_overview.rst:14
msgid ""
"We can also use (accumulate + final) mode to calculate the feature "
"positions. Initially accumulate node is empty, and every run of "
"accumulate node will accumulate the data. There should be at least 4 "
"captures for each feature. When the data are enough, we run final node, "
"which will use the data in accumulate node to calculate the 3d "
"coordinates of feature points related to object origin."
msgstr ""

#: ../nodes/DA Modules/mono_3d_overview.rst:20
msgid "Pose Estimation"
msgstr ""

#: ../nodes/DA Modules/mono_3d_overview.rst:22
msgid ""
"Using the defined object feature positions and captured features from "
"image, we estimate the pose for object, such that the average difference "
"between [estimated feature position on image] and [actual captured "
"feature position on image] is minimum."
msgstr ""

#: ../nodes/DA Modules/mono_3d_overview.rst:26
msgid "Node Paramters"
msgstr ""

#: ../nodes/DA Modules/mono_3d_overview.rst:35
msgid "Accumulate:"
msgstr ""

#: ../nodes/DA Modules/mono_3d_overview.rst:29 Modules/mono_3d_overview.rst:48
msgid "Mod Finder Result:"
msgstr ""

#: ../nodes/DA Modules/mono_3d_overview.rst:30 Modules/mono_3d_overview.rst:49
msgid "Comes from a 2d mod_finder, where we detect features from image."
msgstr ""

#: ../nodes/DA Modules/mono_3d_overview.rst:31 Modules/mono_3d_overview.rst:50
msgid "Pose:"
msgstr ""

#: ../nodes/DA Modules/mono_3d_overview.rst:32 Modules/mono_3d_overview.rst:51
msgid "The robot TCP_in_Base pose."
msgstr ""

#: ../nodes/DA Modules/mono_3d_overview.rst:33 Modules/mono_3d_overview.rst:52
msgid "Calibration Context:"
msgstr ""

#: ../nodes/DA Modules/mono_3d_overview.rst:34 Modules/mono_3d_overview.rst:53
msgid ""
"A eye-in-hand calibration context, should be consistent with the input "
"Pose."
msgstr ""

#: ../nodes/DA Modules/mono_3d_overview.rst:35 Modules/mono_3d_overview.rst:58
msgid "Image:"
msgstr ""

#: ../nodes/DA Modules/mono_3d_overview.rst:36 Modules/mono_3d_overview.rst:57
msgid "For visualizing."
msgstr ""

#: ../nodes/DA Modules/mono_3d_overview.rst:40
msgid "Final:"
msgstr ""

#: ../nodes/DA Modules/mono_3d_overview.rst:38
msgid "Reference Accumulate Node:"
msgstr ""

#: ../nodes/DA Modules/mono_3d_overview.rst:39
msgid "The accumulate Mono 3D Node where this node calculate data from."
msgstr ""

#: ../nodes/DA Modules/mono_3d_overview.rst:40 Modules/mono_3d_overview.rst:45
#: Modules/mono_3d_overview.rst:54
msgid "Name this file:"
msgstr ""

#: ../nodes/DA Modules/mono_3d_overview.rst:41 Modules/mono_3d_overview.rst:46
msgid ""
"The name of file where node save the object feature positions. The file "
"will be saved in the workspace directory."
msgstr ""

#: ../nodes/DA Modules/mono_3d_overview.rst:45 Modules/mono_3d_procedure.rst:11
msgid "Set Feature:"
msgstr ""

#: ../nodes/DA Modules/mono_3d_overview.rst:43
msgid "Set Feature Fields:"
msgstr ""

#: ../nodes/DA Modules/mono_3d_overview.rst:44
msgid "User-defined features."
msgstr ""

#: ../nodes/DA Modules/mono_3d_overview.rst:58 Modules/mono_3d_procedure.rst:15
msgid "Pose Estimate:"
msgstr ""

#: ../nodes/DA Modules/mono_3d_overview.rst:55
msgid "The name of file where node read the object feature positions."
msgstr ""

#: ../nodes/DA Modules/mono_3d_overview.rst:63
msgid ""
"Only Pose_Estimate mode has an output, which is a Vector<Pose> object. "
"The pose object contains the object_in_camera pose."
msgstr ""

#: ../nodes/DA Modules/mono_3d_procedure.rst:2
msgid "Procedure of Using This Node"
msgstr ""

#: ../nodes/DA Modules/mono_3d_procedure.rst:8
msgid "Define Features:"
msgstr ""

#: ../nodes/DA Modules/mono_3d_procedure.rst:5
msgid "Run eye-in-hand calibration, get eye-in-hand calibration context"
msgstr ""

#: ../nodes/DA Modules/mono_3d_procedure.rst:6
msgid "Define at least 4 features on object by 2d mod_finder node."
msgstr ""

#: ../nodes/DA Modules/mono_3d_procedure.rst:7
msgid ""
"From different positions, capture this object and use 2d mod_finder node "
"to find its feature, and run accumulate mode node to accumulate data. "
"each feature on object should be captured at least 4 times."
msgstr ""

#: ../nodes/DA Modules/mono_3d_procedure.rst:8
msgid ""
"run final mode node to calculate the position of feature relative to "
"object."
msgstr ""

#: ../nodes/DA Modules/mono_3d_procedure.rst:11
msgid ""
"As an alternative way of define features, you may input the "
"feature_in_object using position values"
msgstr ""

#: ../nodes/DA Modules/mono_3d_procedure.rst:14
msgid "run eye-in-hand calibration, get calibration context."
msgstr ""

#: ../nodes/DA Modules/mono_3d_procedure.rst:15
msgid "capture object, it should capture at least 4 features."
msgstr ""

#: ../nodes/DA Modules/mono_3d_procedure.rst:16
msgid "run pose_estimate mode node, obtain object_in_camera pose"
msgstr ""

#: ../nodes/DA Modules/shape_finder_overview.rst:13
msgid "Shape"
msgstr ""

#: ../nodes/DA Modules/shape_finder_overview.rst:14
msgid ""
"You can define shape and shape parameters. The parameters for different "
"shape is labelled on the shape model. Please note that the unit of "
"parameters is pixel unit."
msgstr ""

#: ../nodes/DA Modules/shape_finder_overview.rst:23
msgid ""
"On the screen, the pixel units are labelled if you click \"Show Ruler\" "
"in display setting."
msgstr ""

#: ../nodes/DA Modules/shape_finder_overview.rst:31
msgid "The result of shape search is as below"
msgstr ""

#: ../nodes/DA Modules/shape_finder_overview.rst:41
msgid "numFound: (DataType:Int) The total number of occurrences found."
msgstr ""

#: ../nodes/DA Modules/shape_finder_overview.rst:42
msgid "shapeLocations: (DataType:Vector<Pose2D>) Shape 2D poses map."
msgstr ""

#: ../nodes/DA Modules/shape_finder_overview.rst:43
msgid "shapeMasks: (DataType:Vector<Image>)Shape masks map."
msgstr ""

#: ../nodes/DA Modules/shape_finder_overview.rst:44
msgid "success: (DataType:Bool) If all shape search are performed successfully."
msgstr ""

#: ../nodes/DA Modules/shape_finder_procedure.rst:2
msgid "Procedure of Using Shape Finder Node"
msgstr ""

#: ../nodes/DA Modules/shape_finder_procedure.rst:4
msgid "Link input image"
msgstr ""

#: ../nodes/DA Modules/shape_finder_procedure.rst:5
msgid "Run the node, to load the image"
msgstr ""

#: ../nodes/DA Modules/shape_finder_procedure.rst:6
msgid "Open \"show ruler\" in the display option"
msgstr ""

#: ../nodes/DA Modules/shape_finder_procedure.rst:7
msgid ""
"Define shape. the unit of parameters are the unit of ruler showed on "
"display."
msgstr ""

#: ../nodes/DA Modules/shape_finder_procedure.rst:8
msgid "Run the node, will output the poses and mask of founded shape"
msgstr ""

#: ../nodes/DA Modules/shape_finder_procedure.rst:15
msgid "Settings"
msgstr ""

#: ../nodes/DA Modules/shape_finder_procedure.rst:16
msgid "timeout:"
msgstr ""

#: ../nodes/DA Modules/shape_finder_procedure.rst:17
msgid "The time out for the node running. Unit is msec."
msgstr ""

#: ../nodes/DA Modules/shape_finder_procedure.rst:18
msgid "Speed:"
msgstr ""

#: ../nodes/DA Modules/shape_finder_procedure.rst:19
msgid "The speed of searching."
msgstr ""

#: ../nodes/DA Modules/shape_finder_procedure.rst:20
msgid "Accuracy:"
msgstr ""

#: ../nodes/DA Modules/shape_finder_procedure.rst:21
msgid "The accuracy of searching"
msgstr ""

#: ../nodes/DA Modules/shape_finder_procedure.rst:23
msgid "Create Solid Mask:"
msgstr ""

#: ../nodes/DA Modules/shape_finder_procedure.rst:23
msgid ""
"If not clicked, the shape mask will only include the shape edge. But if "
"the solid mask option is clicked, the mask will include include the edge "
"and inside it."
msgstr ""

#: ../nodes/DA Modules/shape_finder_procedure.rst:26
msgid "Shape Settings"
msgstr ""

#: ../nodes/DA Modules/shape_finder_procedure.rst:27
msgid "Shape:"
msgstr ""

#: ../nodes/DA Modules/shape_finder_procedure.rst:28
msgid "The shape to search."
msgstr ""

#: ../nodes/DA Modules/shape_finder_procedure.rst:30
msgid "Foreground Color:"
msgstr ""

#: ../nodes/DA Modules/shape_finder_procedure.rst:30
msgid ""
"The foreground color of shape. For most shape, it is ANY. For Circle "
"shape, it is Black. Circle shape do not support Foreground Color \"ANY\"."
msgstr ""

#: ../nodes/DA Modules/shape_finder_procedure.rst:32
msgid "Param2-6:"
msgstr ""

#: ../nodes/DA Modules/shape_finder_procedure.rst:33
msgid ""
"The param of shape, such as radius of circle. The unit is pixel, as shown"
" on \"show ruler\" option."
msgstr ""

#: ../nodes/DA Modules/shape_finder_procedure.rst:34
msgid "Min Acceptance:"
msgstr ""

#: ../nodes/DA Modules/shape_finder_procedure.rst:35
msgid ""
"Sets the acceptance level for the score. An occurrence will be returned "
"only if the match score between the target and the model is greater than "
"or equal to this level."
msgstr ""

#: ../nodes/DA Modules/shape_finder_procedure.rst:36
msgid "Total Occurrences:"
msgstr ""

#: ../nodes/DA Modules/shape_finder_procedure.rst:37
msgid "The number of occurrences to search."
msgstr ""

#: ../nodes/DA Modules/shape_finder_procedure.rst:38
msgid "Search Region:"
msgstr ""

#: ../nodes/DA Modules/shape_finder_procedure.rst:39
msgid "the search region of shape, can be used with fixture system."
msgstr ""

#: ../nodes/Data Advanced Control/Python Expressions.rst:2 Interpreter and
msgid "Python Interpreter and Advanced Expressions"
msgstr ""

#: ../nodes/Data Advanced Control/Python Expressions.rst:3 Interpreter and
msgid ""
"A python interpreter is used in the evaluation of Advanced Expressions. "
"An Advanced Expression is a way a you can define an input by writing "
"short snippets of simple code which can reference other pieces of "
"information in the system, such as the fields stored in a Constant Node "
"or the number of models found in the Mod Finder V2 Node. An example of an"
" advanced expression is shown below:"
msgstr ""

#: ../nodes/Data Advanced Control/Python Expressions.rst:8 Interpreter and
msgid ""
"In this expression, if the value stored in the integer field of the "
"Constant Node in the flowchart main_flowchart is greater or equal to 5, "
"the advanced expression evaluates to True, otherwise it evaluates to "
"False."
msgstr ""

#: ../nodes/Data Advanced Control/Python Expressions.rst:10 Interpreter and
msgid ""
"Here is another example of an advanced expression which returns different"
" Point Clouds based on if a 3D Model Finder Node performed a successful "
"detection:"
msgstr ""

#: ../nodes/Data Advanced Control/Python Expressions.rst:15 Interpreter and
msgid ""
"Advanced expressions are evaluated using a Python Interpreter, so all "
"logic used must follow Python syntax (':' after 'if' statements, proper "
"tabbing, etc), however advanced expressions must also contain a 'RETURN' "
"keyword to signify what the output of the expression should be. Other "
"keywords specific to DaoAI Advanced Expressions are INT((...)), "
"DOUBLE(...), BOOL((...)), STRING((...)), and OBJECT((...)) which are used"
" to evaluate expressions referring to data in other nodes of the system."
msgstr ""

#: ../nodes/Data Control/Quick Evaluate.rst:2
msgid "Quick Evaluate"
msgstr ""

#: ../nodes/Data Control/Quick Evaluate.rst:3
msgid ""
"The Quick Evaluate page can be accessed as another tab alongside "
"'Console' and 'Recipes'. It can be used to evaluate expressions referring"
" to values in the workspace."
msgstr ""

#: ../nodes/Data Control/Quick Evaluate.rst:8
msgid ""
"Expressions can be added to the evaluation table by selecting one in the "
"'Available Expressions'. The expressions can be modified once inside of "
"the evaluation table in order to add in an index or map key, such as "
"would be required for expressions containing in [] (vector requiring "
"integer index) or [''] (map requiring string key)."
msgstr ""

#: ../nodes/Data Control/Quick Evaluate.rst:10
msgid ""
"As the flowchart runs, the expressions will be continuously evaluated and"
" refreshed to reflect their changing values."
msgstr ""

#: ../nodes/Data Control/index.rst:2
msgid "Data Control"
msgstr ""

#: ../nodes/Flowchart_control/Break Node.rst:2
msgid "Break Node"
msgstr ""

#: ../nodes/Flowchart_control/Break Node.rst:6
msgid "Node used inside of **For Loops** to terminate the loop's execution."
msgstr ""

#: ../nodes/Flowchart_control/Break Node.rst:11
msgid ""
"Has a single field 'Condition', which when evaluates to true, causes the "
"For Loop which the Break Node is in to be broken out of."
msgstr ""

#: ../nodes/Flowchart_control/Break Node.rst:16
msgid ""
"In this image we see a Break Node which was automatically placed at the "
"end of the sub-flowchart in a Loop Node."
msgstr ""

#: ../nodes/Flowchart_control/Break Node.rst:18
msgid "A break node can not be inserted outside of a For Loop."
msgstr ""

#: ../nodes/Flowchart_control/Break Node.rst:33
msgid "Function Signature"
msgstr ""

#: ../nodes/Flowchart_control/Break Node.rst:44
msgid "initial_value"
msgstr ""

#: ../nodes/Flowchart_control/Break Node.rst:44 Node.rst:55
msgid "column 4"
msgstr ""

#: ../nodes/Flowchart_control/Break Node.rst:46 Node.rst:57
msgid "body row 2"
msgstr ""

#: ../nodes/Flowchart_control/Break Node.rst:46 Node.rst:57
msgid "..."
msgstr ""

#: ../nodes/Flowchart_control/Break Node.rst:53
msgid "Header row, column 1"
msgstr ""

#: ../nodes/Flowchart_control/Break Node.rst:53
msgid "Header 2"
msgstr ""

#: ../nodes/Flowchart_control/Break Node.rst:53
msgid "Header 3"
msgstr ""

#: ../nodes/Flowchart_control/Break Node.rst:53
msgid "Header 4"
msgstr ""

#: ../nodes/Flowchart_control/Break Node.rst:55
msgid "body row 1, column 1"
msgstr ""

#: ../nodes/Flowchart_control/Break Node.rst:55
msgid "column 2"
msgstr ""

#: ../nodes/Flowchart_control/Break Node.rst:55
msgid "column 3"
msgstr ""

#: ../nodes/Flowchart_control/Condition Node.rst:2
msgid "Condition Node"
msgstr ""

#: ../nodes/Flowchart_control/Condition Node.rst:6
msgid ""
"Node used to execute either of two sub-flowcharts based on an inputted "
"expression."
msgstr ""

#: ../nodes/Flowchart_control/Condition Node.rst:11
msgid ""
"Has two sub-flowcharts and a single input, 'Condition'. When 'Condition' "
"evaluates to True, the sub-flowchart corresponding to True is evaluated, "
"when 'Condition' evaluates to False the sub-flowchart corresponding to "
"False is evaluated."
msgstr ""

#: ../nodes/Flowchart_control/Condition Node.rst:16
msgid ""
"In this image we see a Condition Node serve to either go through a Pick "
"Sort operation or to simply do nothing based off of the output from a "
"Collision Avoidance Node."
msgstr ""

#: ../nodes/Flowchart_control/Condition ../nodes/Flowchart_control/Continue
#: Node.rst:23 Node.rst:27
msgid "Condition:"
msgstr ""

#: ../nodes/Flowchart_control/Condition Node.rst:22
msgid ""
"An expression which must evaluate to a boolean. When true, the sub-"
"flowchart corresponding to True is evaluated, when false the sub-"
"flowchart corresponding to False is evaluated."
msgstr ""

#: ../nodes/Flowchart_control/Condition ../nodes/Flowchart_control/Continue
#: ../nodes/Flowchart_control/Switch Node.rst:28 Node.rst:30
msgid "The boolean value of the input Condition expression."
msgstr ""

#: ../nodes/Flowchart_control/Constant ../nodes/Flowchart_control/Continue
#: Node.rst:2
msgid "Constant Node"
msgstr ""

#: ../nodes/Flowchart_control/Constant Node.rst:6
msgid "Node used to hold constant values to be referenced in other nodes."
msgstr ""

#: ../nodes/Flowchart_control/Constant Node.rst:11
msgid ""
"Can hold integer, double, string, or boolean values to be referenced in "
"other nodes."
msgstr ""

#: ../nodes/Flowchart_control/Constant Node.rst:16
msgid "This image shows a Constant Node holding various values."
msgstr ""

#: ../nodes/Flowchart_control/Constant Node.rst:21 Node.rst:33
msgid "Int Field:"
msgstr ""

#: ../nodes/Flowchart_control/Constant Node.rst:22
msgid "Integer-type value to be inputted by user."
msgstr ""

#: ../nodes/Flowchart_control/Constant Node.rst:23 Node.rst:35
msgid "Double Field:"
msgstr ""

#: ../nodes/Flowchart_control/Constant Node.rst:24
msgid "Double-type value to be inputted by user."
msgstr ""

#: ../nodes/Flowchart_control/Constant Node.rst:25 Node.rst:37
msgid "Bool Field:"
msgstr ""

#: ../nodes/Flowchart_control/Constant Node.rst:26
msgid "Boolean-type value to be inputted by user."
msgstr ""

#: ../nodes/Flowchart_control/Constant Node.rst:29 Node.rst:39
msgid "String Field:"
msgstr ""

#: ../nodes/Flowchart_control/Constant Node.rst:28
msgid "String-type value to be inputted by user."
msgstr ""

#: ../nodes/Flowchart_control/Constant Node.rst:34
msgid "Integer-type value inputted by user."
msgstr ""

#: ../nodes/Flowchart_control/Constant Node.rst:36
msgid "Double-type value inputted by user."
msgstr ""

#: ../nodes/Flowchart_control/Constant Node.rst:38
msgid "Boolean-type value inputted by user."
msgstr ""

#: ../nodes/Flowchart_control/Constant Node.rst:40
msgid "String-type value inputted by user."
msgstr ""

#: ../nodes/Flowchart_control/Continue Node.rst:6
msgid ""
"Node used inside of For Loops to forward loop execution to the next loop "
"iteration."
msgstr ""

#: ../nodes/Flowchart_control/Continue Node.rst:11
msgid ""
"Has a single input, 'Condition', that when evaluates to True, forwards "
"the execution of the loop that the node is in to the next loop iteration."
" This node allows the you to skip part of a For Loop sub-flowchart by "
"simply going to the next iteration."
msgstr ""

#: ../nodes/Flowchart_control/Continue Node.rst:16
msgid ""
"In this Loop Node, we see a Continue Node used to skip an Image Process "
"operation when a condition is not met."
msgstr ""

#: ../nodes/Flowchart_control/Continue Node.rst:22
msgid ""
"An expression which must evaluate to a boolean. When true the loop which "
"the Continue Node is in is forwarded to its next iteration."
msgstr ""

#: ../nodes/Flowchart_control/Flowchart Node.rst:2
msgid "Flowchart Node"
msgstr ""

#: ../nodes/Flowchart_control/Flowchart Node.rst:6
msgid ""
"Node used to nest a flowchart as a sub-flowchart in the flowchart the "
"node is placed into."
msgstr ""

#: ../nodes/Flowchart_control/Flowchart Node.rst:11
msgid ""
"Has a single input, 'Flowchart Name', which is the name of the other "
"flowchart that is run when this node is executed. Upon placement of this "
"node, you are prompted to select which flowchart the node should execute:"
msgstr ""

#: ../nodes/Flowchart_control/Flowchart Node.rst:17
msgid ""
"In this example below using of a Flowchart Node, we see that upon a "
"certain condition specific in the Switch Node, an entire flowchart would "
"be run by just placing the single Flowchart Node."
msgstr ""

#: ../nodes/Flowchart_control/Flowchart Node.rst:27 Node.rst:31
msgid "Flowchart Name:"
msgstr ""

#: ../nodes/Flowchart_control/Flowchart Node.rst:26 Node.rst:32
msgid "Name of the other flowchart that runs when this node is executed."
msgstr ""

#: ../nodes/Flowchart_control/Halt Node.rst:2
msgid "Halt Node"
msgstr ""

#: ../nodes/Flowchart_control/Halt Node.rst:6
msgid "Node used to halt flowchart execution."
msgstr ""

#: ../nodes/Flowchart_control/Halt Node.rst:11
msgid ""
"Halts flowchart execution until the node input 'Halt' expression "
"evaluates to False."
msgstr ""

#: ../nodes/Flowchart_control/Halt Node.rst:16
msgid ""
"In this example of a Halt Node in use, we see that it would halt "
"execution until the linked Mod Finder V2 Node has executed successfully."
msgstr ""

#: ../nodes/Flowchart_control/Halt Node.rst:22 Node.rst:26
msgid "Halt:"
msgstr ""

#: ../nodes/Flowchart_control/Halt Node.rst:21
msgid ""
"An expression which must evaluate to a boolean. When true the execution "
"of the flowchart is halted at this node."
msgstr ""

#: ../nodes/Flowchart_control/Halt Node.rst:27
msgid "The boolean value of the input Halt expression."
msgstr ""

#: ../nodes/Flowchart_control/Loop Node.rst:2
msgid "Loop Node"
msgstr ""

#: ../nodes/Flowchart_control/Loop Node.rst:6
msgid "Node used to create a loop which executes until a break condition is met."
msgstr ""

#: ../nodes/Flowchart_control/Loop Node.rst:11
msgid ""
"Generates a sub-flowchart with a Break Node that gets iteratively "
"executed until the condition defined in a Break Node (which can be the "
"one generated upon placing the Loop Node, or by another Break Node placed"
" by the user) evaluates to True."
msgstr ""

#: ../nodes/Flowchart_control/Loop Node.rst:16
msgid ""
"The image above shows a Loop Node placed without any modifications. The "
"Break Node is automatically inserted."
msgstr ""

#: ../nodes/Flowchart_control/Loop Node.rst:21
msgid "Iteration:"
msgstr ""

#: ../nodes/Flowchart_control/Loop Node.rst:22
msgid ""
"The number of times the loop has currently executed. Is reset to 0 every "
"time the loop begins executing."
msgstr ""

#: ../nodes/Flowchart_control/Switch Node.rst:2
msgid "Switch Node"
msgstr ""

#: ../nodes/Flowchart_control/Switch Node.rst:6
msgid ""
"A generalization of the Condition Node to greater than or equal to 2 "
"cases used to execute one of many sub-flowcharts based on expressions for"
" each case."
msgstr ""

#: ../nodes/Flowchart_control/Switch Node.rst:11
msgid ""
"Upon placement, generates two sub-flowcharts, 'Case 1' and 'Default' "
"although you can then add as many other cases as required. Each case has "
"an input 'Condition:case_X' which when evaluates to true, causes that "
"case's sub-flowchart to be executed when the switch node is hit. If "
"multiple cases have conditions which evaluate to True, the first case's "
"sub-flowchart only will be executed (i.e. if Case 1 and Case 2 both have "
"input conditions that evaluate to True, only Case 1's sub-flowchart would"
" be executed). If no cases evaluate to True, the Default case's sub-"
"flowchart will execute."
msgstr ""

#: ../nodes/Flowchart_control/Switch Node.rst:18
msgid ""
"The images above show a Switch Node could be used to switch between "
"different calibration types."
msgstr ""

#: ../nodes/Flowchart_control/Switch Node.rst:25 Node.rst:29
msgid "Condition\\:case_X:"
msgstr ""

#: ../nodes/Flowchart_control/Switch Node.rst:24
msgid ""
"An expression which must evaluate to a boolean. When true, the sub-"
"flowchart corresponding to this case is evaluated as long as no other "
"conditions corresponding to cases of lower numbers also evaluate to True."
msgstr ""

#: ../nodes/Flowchart_control/index.rst:2
msgid "Flowchart Control"
msgstr ""

#: ../nodes/Flowchart_control/index.rst:4
msgid ""
"Normally, a flowchart runs sequentially from top to bottom. To have a "
"more programmable flowchart we use flowchart control node to alter the "
"order of flowchart run."
msgstr ""

#: ../nodes/Image Processing/image_process.rst:2
msgid "Image Process Node"
msgstr ""

#: ../nodes/Image Processing/image_process.rst:4
msgid ""
"Image process node gives you the ability to perform several image "
"processing operations on an input image."
msgstr ""

#: ../nodes/Image Processing/image_process_detail.rst:2
msgid "Procedure for Using Image Process Node"
msgstr ""

#: ../nodes/Image Processing/image_process_detail.rst:5
msgid ""
"Image processing node gives you the ability to perform several image "
"processing operations on input images. The input of this node is an image"
" which is usually linked to the reader or the camera node. An example of "
"an input image and linking the input is shown below."
msgstr ""

#: ../nodes/Image Processing/image_process_detail.rst:18
msgid ""
"In order to choose an operation or a set of operations, you can choose "
"the plus sign under the 'Set Operations' section."
msgstr ""

#: ../nodes/Image Processing/image_process_detail.rst:25
msgid ""
"By clicking the add button, an operation will be added to the operation "
"list. By default, this operation will be a \"Resize\" operation. In order"
" to change the chosen operation, click on the added operation. Then, as "
"shown below, you will be able to see a set of operations to choose from."
msgstr ""

#: ../nodes/Image Processing/image_process_detail.rst:38
msgid ""
"Note that base on your needs, you can choose as many as operations you "
"want to be performed by order on the input image. In the next section, "
"each of the available operations are explained."
msgstr ""

#: ../nodes/Image Processing/image_process_detail.rst:41
msgid "Resize"
msgstr ""

#: ../nodes/Image Processing/image_process_detail.rst:42
msgid ""
"This operation resizes the input into a user-specified size. An example "
"of the settings of this operation is shown below."
msgstr ""

#: ../nodes/Image Processing/image_process_detail.rst:53
msgid "To Gray"
msgstr ""

#: ../nodes/Image Processing/image_process_detail.rst:54
msgid ""
"This operation converts the input image into a gray scale image with "
"user-specified weights to control the gray level. An example of this "
"settings is shown below."
msgstr ""

#: ../nodes/Image Processing/image_process_detail.rst:61
msgid ""
"The user-specified values R,G and B will determine each of the channels "
"weights when converting to gray scale. The sum of wights should be equal "
"to 1. The default value for each channel is 0.33. An example of an input "
"image and output using the 'To Gray' operation are shown below, "
"respectively."
msgstr ""

#: ../nodes/Image Processing/image_process_detail.rst:76
msgid "ROI"
msgstr ""

#: ../nodes/Image Processing/image_process_detail.rst:77
msgid ""
"Using this operation, you can define a rectangular Region Of Interest "
"(ROI) in the input image and crop it out as the output. The image below "
"shows the settings of this operation."
msgstr ""

#: ../nodes/Image Processing/image_process_detail.rst:84
msgid ""
"As it can be seen, you need to define a region of interest graphically or"
" manually by entering the pixel locations of the ROI1 (top left corner "
"pixel location) and ROI2 (bottom right corner pixel location). By "
"default, the output image will have the same size as the input image. "
"However, you can resize the output image to the ROI size if needed by "
"unchecking the \"Keep Image Size Constant\" checkbox."
msgstr ""

#: ../nodes/Image Processing/image_process_detail.rst:87
msgid ""
"An example of the input image and the output image using the above "
"settings is shown below, respectively."
msgstr ""

#: ../nodes/Image Processing/image_process_detail.rst:99
msgid ""
"Note that you also has the choice of excluding the chosen ROI by checking"
" the \"Inverse\" option."
msgstr ""

#: ../nodes/Image Processing/image_process_detail.rst:102
msgid "Threshold"
msgstr ""

#: ../nodes/Image Processing/image_process_detail.rst:103
msgid ""
"This operation performs a global thresholding (binarization) on the input"
" image based on the user-specified threshold value. The image below shows"
" the settings of this operation."
msgstr ""

#: ../nodes/Image Processing/image_process_detail.rst:110
msgid ""
"The user-specified threshold should have a value in range of 0 to 255 and"
" determines the threshold used for binarization."
msgstr ""

#: ../nodes/Image Processing/image_process_detail.rst:123
msgid "Logic AND"
msgstr ""

#: ../nodes/Image Processing/image_process_detail.rst:124
msgid ""
"This operation performs logic AND operation between the input image and "
"user-specified image. The image below shows the settings of this "
"operation."
msgstr ""

#: ../nodes/Image Processing/image_process_detail.rst:131
msgid ""
"As shown in the image above, you have to define an additional image in "
"the operation config page which is used for AND operation with the node "
"input image. An example of the node image input, user-specified image for"
" AND operation and the output image of this is below , respectively."
msgstr ""

#: ../nodes/Image Processing/image_process_detail.rst:150
msgid "Logic NOT"
msgstr ""

#: ../nodes/Image Processing/image_process_detail.rst:151
msgid ""
"This operation performs logic NOT operation on the input image. Example "
"of the input image and output using this operation is shown below."
msgstr ""

#: ../nodes/Image Processing/image_process_detail.rst:164
msgid "Logic OR"
msgstr ""

#: ../nodes/Image Processing/image_process_detail.rst:165
msgid ""
"This operation performs logic OR operation between the input image and "
"user-specified image. The image below shows the settings of this "
"operation."
msgstr ""

#: ../nodes/Image Processing/image_process_detail.rst:172
msgid ""
"As shown in the image above, you have to define an additional image in "
"the operation config page which is used for OR operation with the node "
"input image. An example of the node image input, user-specified image for"
" OR operation and the output image of this is shown below, respectively."
msgstr ""

#: ../nodes/Image Processing/image_process_detail.rst:191
msgid "Erode"
msgstr ""

#: ../nodes/Image Processing/image_process_detail.rst:192
msgid ""
"This operation performs erosion operation on the input image using the "
"user-specified parameters (number of erosion iterations and used kernel "
"size). The image below shows the settings of this operation."
msgstr ""

#: ../nodes/Image Processing/image_process_detail.rst:199
msgid ""
"Using a bigger kernel size and number of iterations will result in more "
"erosion of the input image. An example of the input image and output "
"using this operation is shown below."
msgstr ""

#: ../nodes/Image Processing/image_process_detail.rst:212
msgid "Dilate"
msgstr ""

#: ../nodes/Image Processing/image_process_detail.rst:213
msgid ""
"This operation performs dilation operation on the input image using the "
"user-specified parameters (number of dilation iterations and used kernel "
"size). The image below shows the settings of this operation."
msgstr ""

#: ../nodes/Image Processing/image_process_detail.rst:220
msgid ""
"Using a bigger kernel size and number of iterations will result in more "
"dilation of the input image. An example of the input image and output "
"using this operation is shown below."
msgstr ""

#: ../nodes/Image Processing/image_process_detail.rst:233
msgid "Apply mask"
msgstr ""

#: ../nodes/Image Processing/image_process_detail.rst:234
msgid ""
"This operation applies a mask to the input image. The mask input can be "
"linked to a node which produces a mask, or by reading in a mask image "
"using a Reader/Camera node. The image below shows the settings of this "
"operation."
msgstr ""

#: ../nodes/Image Processing/image_process_detail.rst:241
msgid ""
"As shown in the image above, you have to define an additional image in "
"the operation config page which is the mask used for this operation. An "
"example of the node input input image, input mask and resulted output is "
"shown below."
msgstr ""

#: ../nodes/Image Processing/image_process_detail.rst:249
msgid "Crop Around Mask"
msgstr ""

#: ../nodes/Image Processing/image_process_detail.rst:250
msgid ""
"This operation crops the image around a mask with size of the user-"
"specifications in pixels. This operation was added to produce cropped "
"images which can then be fed into DL models. The image below shows the "
"settings of this operation."
msgstr ""

#: ../nodes/Image Processing/image_process_detail.rst:257
msgid "An example of the input image and resulting output image is shown below."
msgstr ""

#: ../nodes/Image Processing/image_process_detail.rst:265
msgid "No-Op"
msgstr ""

#: ../nodes/Image Processing/image_process_detail.rst:266
msgid "This option outputs the same image as the input image."
msgstr ""

#: ../nodes/Image Processing/image_process_overview.rst:7
msgid "Image_In (type:Image) : Input image for image process operations."
msgstr ""

#: ../nodes/Image Processing/image_process_overview.rst:12
msgid ""
"imageOutput (type:Image) : Output image after performing different "
"operations on the input image."
msgstr ""

#: ../nodes/Image Processing/index.rst:2
msgid "Image Process Nodes"
msgstr ""

#: ../nodes/Recipes/index.rst:2
msgid "Recipe nodes"
msgstr ""

#: ../nodes/Recipes/index.rst:4
msgid ""
"This section contains basic introduction about the concept of the recipe "
"and how to use the recipe nodes."
msgstr ""

#: ../nodes/Recipes/index.rst:8
msgid "Processing Nodes Vs Definition Nodes"
msgstr ""

#: ../nodes/Recipes/index.rst:10
msgid ""
"Processing nodes are nodes that doesn't require re-configuration in "
"field. For example, camera nodes. Due to such reason these nodes are not "
"able to store configuration in recipe Definition Nodes, on the other "
"hand, are nodes that may have changing configuration in field "
"application, or their configuration requires user-interaction (such as "
"adjust bounding box filtering in cloud process node). These nodes are "
"able to store information in the recipe."
msgstr ""

#: ../nodes/Recipes/index.rst:15
msgid "Complete List of Definition Nodes"
msgstr ""

#: ../nodes/Recipes/index.rst:17
msgid "Mesh Process"
msgstr ""

#: ../nodes/Recipes/index.rst:18
msgid "Calibration"
msgstr ""

#: ../nodes/Recipes/index.rst:19
msgid "Mod Finder"
msgstr ""

#: ../nodes/Recipes/index.rst:20
msgid "Sphere Calibration"
msgstr ""

#: ../nodes/Recipes/index.rst:21
msgid "Reader"
msgstr ""

#: ../nodes/Recipes/index.rst:22
msgid "Hand Eye Calibration 2d"
msgstr ""

#: ../nodes/Recipes/index.rst:23
msgid "Hand Eye Calibration 2d V2"
msgstr ""

#: ../nodes/Recipes/index.rst:24
msgid "Calibration 2d"
msgstr ""

#: ../nodes/Recipes/index.rst:25
msgid "DA Calibration"
msgstr ""

#: ../nodes/Recipes/index.rst:26
msgid "Gripper"
msgstr ""

#: ../nodes/Recipes/index.rst:27
msgid "Assemble possible"
msgstr ""

#: ../nodes/Recipes/index.rst:28
msgid "DL segmentation"
msgstr ""

#: ../nodes/Recipes/index.rst:29
msgid "DL classification"
msgstr ""

#: ../nodes/Recipes/index.rst:30
msgid "Object Finder 3d"
msgstr ""

#: ../nodes/Recipes/index.rst:33
msgid "An Example on How to Use the Recipe Feature"
msgstr ""

#: ../nodes/Recipes/index.rst:35
msgid ""
"We use this simple workspace to illustrate how we can use recipe. In this"
" workspace, camera node captures a point cloud, then the point cloud is "
"converted to a depth image, based on this depth image mod finder finds "
"the 3d locations of defined objects in the camera scene. By default, we "
"have only 1 recipe, and no nodes store info in recipe now."
msgstr ""

#: ../nodes/Recipes/index.rst:43
msgid "Add/Remove Recipe, Add Node to Recipe"
msgstr ""

#: ../nodes/Recipes/index.rst:45
msgid ""
"From the recipe panel on the bottom of the main window you can add and "
"remove recipe. To tell a node to store its information in recipes, right "
"click on the node and select \"Add Node To Recipe\". Once that's "
"successful, you will see a small R icon on the top left of the node."
msgstr ""

#: ../nodes/Recipes/index.rst:52
msgid "Switch Recipes"
msgstr ""

#: ../nodes/Recipes/index.rst:54
msgid ""
"Now we have two recipes are we want to define a model for mod finder node"
" for each recipe. In recipe 1, We run the flow chart from the start to "
"mod finder node, and define a model"
msgstr ""

#: ../nodes/Recipes/index.rst:60
msgid ""
"Double click recipe_2 in the recipe panel to switch to recipe_2, re-run "
"the process to define another model"
msgstr ""

#: ../nodes/Recipes/index.rst:65
msgid ""
"Now switch back to recipe_1, you should see the first model in the mod "
"finder node. Now we have two recipes to search for different models."
msgstr ""

#: ../nodes/Recipes/index.rst:68 ../nodes/Utility/load_recipe.rst:2
msgid "Load Recipe Node"
msgstr ""

#: ../nodes/Recipes/index.rst:70
msgid ""
"All the creation and definition work of the recipes must be done before "
"the project deployed to the field. However, users are able to switch "
"recipe automatically using the load recipe node."
msgstr ""

#: ../nodes/Recipes/index.rst:76
msgid ""
"When the load recipe node is run, it loads the recipe in its recipe table"
" specified by the input index. You can add or remove recipe entry in the "
"table by clicking add or remove button. The index of the entry is unique "
"and fixed once it is added. The recipe name of each entry and the index "
"name to load can be manually changed or linked, giving you the "
"flexibility to automatically load specific recipes."
msgstr ""

#: ../nodes/Robot/Communication.rst:2
msgid "Robot Communication"
msgstr ""

#: ../nodes/Robot/Operation.rst:2
msgid "Robot Operation"
msgstr ""

#: ../nodes/Robot/index.rst:2
msgid "Robot Related"
msgstr ""

#: ../nodes/Utility/bag.rst:2
msgid "Assemble Bag Node, Disassemble Bag Node"
msgstr ""

#: ../nodes/Utility/bag.rst:4
msgid ""
"Bag is our special data type that combines point cloud, image, pose and "
"camera intrinsic together."
msgstr ""

#: ../nodes/Utility/bag.rst:7
msgid "Assemble Bag Node"
msgstr ""

#: ../nodes/Utility/bag.rst:9
msgid ""
"This node allows us to put together different data and create a bag data "
"as an output."
msgstr ""

#: ../nodes/Utility/bag.rst:17
msgid "Image: rgb image to be put into the bag"
msgstr ""

#: ../nodes/Utility/bag.rst:18
msgid "Depth Image: depth image to be put into the bag"
msgstr ""

#: ../nodes/Utility/bag.rst:19
msgid "Point Cloud: point cloud to be put into the bag"
msgstr ""

#: ../nodes/Utility/bag.rst:20
msgid ""
"Camera intrinsic: camera intrinsic to be put into the bag, usually from "
"camera node, or output from disassemble bag node"
msgstr ""

#: ../nodes/Utility/bag.rst:21
msgid "Pose: pose data to be put into the bag, can be any pose"
msgstr ""

#: ../nodes/Utility/bag.rst:23
msgid ""
"Note that all fields above are optional, you can combine arbitrary number"
" of fields(at lease one) to create a bag"
msgstr ""

#: ../nodes/Utility/bag.rst:26 ../nodes/Utility/bag.rst:44
#: ../nodes/Utility/count.rst:7 ../nodes/Utility/pose.rst:22
#: ../nodes/Utility/pose.rst:39
msgid "output"
msgstr ""

#: ../nodes/Utility/bag.rst:28
msgid "A bag data"
msgstr ""

#: ../nodes/Utility/bag.rst:31
msgid "Disassemble Bag Node"
msgstr ""

#: ../nodes/Utility/bag.rst:33
msgid "This node does the reverse process of assemble bag node"
msgstr ""

#: ../nodes/Utility/bag.rst:41
msgid "A bag data, usually from the output of reader node or assemble bag node"
msgstr ""

#: ../nodes/Utility/bag.rst:46
msgid ""
"Same as the input felids of assemble bag node, a out field contains value"
" if only there is such data in the input bag"
msgstr ""

#: ../nodes/Utility/count.rst:2
msgid "Count Node"
msgstr ""

#: ../nodes/Utility/count.rst:4
msgid ""
"A counter node that increases its counter every time the node has been "
"run, usually used in loop control"
msgstr ""

#: ../nodes/Utility/count.rst:8
msgid ""
"count : number of time the count node has been run, note that the rest "
"button on top of flowchart to reset the counter to 0"
msgstr ""

#: ../nodes/Utility/index.rst:2
msgid "Utility Functions"
msgstr ""

#: ../nodes/Utility/index.rst:4
msgid "This section introduces the utility nodes that we have."
msgstr ""

#: ../nodes/Utility/load_recipe.rst:4
msgid ""
"This node allows you to load recipe automatically. For more information "
"about the recipe, refer to recipe section. This node contains a table of "
"recipe names. Users can add/remove recipe names in the table, when the "
"node is run, it loads the recipe with the input index."
msgstr ""

#: ../nodes/Utility/load_recipe.rst:14
msgid ""
"Index : the index in node's recipe table, corresponding recipe will be "
"loaded"
msgstr ""

#: ../nodes/Utility/pose.rst:2
msgid "Assemble Pose Node, Disassemble Pose Node"
msgstr ""

#: ../nodes/Utility/pose.rst:4
msgid ""
"These two nodes provide functionalities to create a pose (3d "
"transformation matrix) or analyze a pose."
msgstr ""

#: ../nodes/Utility/pose.rst:7
msgid "Assemble Pose Node"
msgstr ""

#: ../nodes/Utility/pose.rst:9
msgid ""
"Assemble pose node allows users to create a 3d transformation matrix with"
" specified parameter."
msgstr ""

#: ../nodes/Utility/pose.rst:16
msgid "Pos X, Pos Y, Pos Z : translation in X,Y,Z axis in the pose"
msgstr ""

#: ../nodes/Utility/pose.rst:17
msgid ""
"Rotate X, Rotate Y, Rotate Z : rotation angles around X,Y,Z axis, in "
"degrees. In Quaternion mode, these corresponds to first 3 numbers in "
"quaternion. In angle-axis mode this represents an axis"
msgstr ""

#: ../nodes/Utility/pose.rst:18
msgid ""
"W : 4th number in quaternion, or rotation angles in degrees in axis-angle"
" mode"
msgstr ""

#: ../nodes/Utility/pose.rst:19 ../nodes/Utility/pose.rst:36
msgid "Order : type of rotation"
msgstr ""

#: ../nodes/Utility/pose.rst:23
msgid "A pose that contains assembled transformation matrix"
msgstr ""

#: ../nodes/Utility/pose.rst:26
msgid "Disassemble Pose Node"
msgstr ""

#: ../nodes/Utility/pose.rst:28
msgid ""
"Disassemble pose node decomposes the input pose and print the result on "
"console"
msgstr ""

#: ../nodes/Utility/pose.rst:35
msgid "Pose : input pose to analyze"
msgstr ""

#: ../nodes/Utility/pose.rst:40
msgid "No output, the result is printed in the console"
msgstr ""

#: ../nodes/Utility/reader_writer.rst:2
msgid "Reader Node and Writer Node"
msgstr ""

#: ../nodes/Utility/reader_writer.rst:5
msgid "Reader Node"
msgstr ""

#: ../nodes/Utility/reader_writer.rst:10
msgid ""
"The Reader Node allows for reading common file types for use in the "
"flowchart."
msgstr ""

#: ../nodes/Utility/reader_writer.rst:12
msgid ""
"Currently, four types of files are available: * RGB images (in .png "
"format by default) * Depth images (in .tif format by default) * PCL Point"
" Cloud (in .pcd format) * Polygon Mesh (in .ply, .stl, .obj format) * Bag"
" files (.bag format)"
msgstr ""

#: ../nodes/Utility/reader_writer.rst:19
msgid ""
"The reader node is capable of reading from a file or folder. This node "
"also saves the cache of files it reads so that it can load it in next "
"time and not have to read it from an external location next time."
msgstr ""

#: ../nodes/Utility/reader_writer.rst:21
msgid "Three source types are available:"
msgstr ""

#: ../nodes/Utility/reader_writer.rst:23
msgid "Read from file: Reads from a single file"
msgstr ""

#: ../nodes/Utility/reader_writer.rst:24
msgid "Read from folder: Reads from files inside a folder"
msgstr ""

#: ../nodes/Utility/reader_writer.rst:25
msgid ""
"Read from numbered: Reads from files with the same naming scheme ending "
"in a number"
msgstr ""

#: ../nodes/Utility/reader_writer.rst:27
msgid ""
"If you chose a file with a non-supported extension, the program will give"
" an error message. Also, if reading from a folder or in numbered orders, "
"the program will give an error message if the folder is empty or, it does"
" not include any of the valid extensions, or in case the more than one "
"valid extension type exists in the folder."
msgstr ""

#: ../nodes/Utility/reader_writer.rst:30
msgid "Read From a single file"
msgstr ""

#: ../nodes/Utility/reader_writer.rst:32
msgid ""
"In this mode the node will read the same file whenever it runs, unless "
"the specified path is changed"
msgstr ""

#: ../nodes/Utility/reader_writer.rst:35
msgid "Read From Folder"
msgstr ""

#: ../nodes/Utility/reader_writer.rst:37
msgid ""
"In this mode the node will iterate through all the files in the given "
"folder and read one file in each run, this mode supports forward "
"traversal (lexicographical) and backward traversal. Please note that only"
" one type of file can be in the given folder otherwise the reader node "
"will not know which type of data to read. You can also reset iterator "
"with the \"reset values\" button."
msgstr ""

#: ../nodes/Utility/reader_writer.rst:42
msgid "Read From Numbered Files"
msgstr ""

#: ../nodes/Utility/reader_writer.rst:44
msgid ""
"This is the more advanced version of reading from folder mode. Here you "
"can specify the file prefix and index. For example, if the prefix is "
"`daoai_` and index range is between 0 and 12, the node will read from "
"daoai_0 to daoai_12, and start from 0 again. You can also reset iterator "
"with the \"reset values\" button."
msgstr ""

#: ../nodes/Utility/reader_writer.rst:50
msgid ""
"The output of this node will have one of these fields valid: outputBag, "
"outputCloud, outputImage (depth or rgb), outputMesh, depending on the "
"file being read. It also has numOfFiles output, which indicates number of"
" files read so far (in read from folder mode), and index, which shows the"
" current index (in read from numbered mode)."
msgstr ""

#: ../nodes/Utility/reader_writer.rst:54
msgid "Writer Node"
msgstr ""

#: ../nodes/Utility/reader_writer.rst:56
msgid "Writer nodes write certain types of data to files in disk"
msgstr ""

#: ../nodes/Utility/reader_writer.rst:61
msgid ""
"Different from the reader node you have to choose which type of data you "
"want to store. Like reader nodes, writer nodes also have single file mode"
" and numbered file mode."
msgstr ""

#: ../nodes/Utility/reader_writer.rst:66
msgid "One of RGB image, depth image, point cloud, mesh, bag."
msgstr ""

#: ../nodes/Utility/transformation_tree.rst:2
msgid "Transformation Tree Node"
msgstr ""

#: ../nodes/Utility/transformation_tree.rst:4
msgid ""
"This is a utility node that creates a relationship graph of relative "
"positions of objects. There are two steps involved in using this node. "
"The first step is to define a set of relationships between objects "
"positions and their relative transformations then we can query the "
"internal graph to produce a list of transformations as the output."
msgstr ""

#: ../nodes/Utility/transformation_tree.rst:14
msgid ""
"The input can be any number of pose items, each item represents a "
"transformation from one coordinate system to another. * Object A name: "
"The name of first object, same object much have same name across all pose"
" items otherwise the node will not work properly * Object B name: The "
"name of second object * A in B transformation: A pose data representing, "
"A's relative position in B's coordinate system, this input field can be "
"linked with other nodes' output, or you can manually set the pose All "
"thse pose item will result in a transformation graph that contains a path"
" between any two objects in the pose items (if such path exist)."
msgstr ""

#: ../nodes/Utility/transformation_tree.rst:23
msgid ""
"This node can have any number of output fields. Each output represents a "
"path (combined transformation) from one object to another. You have to "
"set up the name of two object in order to get the output. The final "
"output will be a vector of the poses (each generated by one query). The "
"order of output is the same as what appears in the user-interface"
msgstr ""

#: ../nodes/Utility/transformation_tree.rst:28
msgid "Example"
msgstr ""

#: ../nodes/Utility/transformation_tree.rst:30
msgid ""
"Consider the case where you have transformation from a to b and from b to"
" c, now you want to now the transformation from a to c."
msgstr ""

#: ../nodes/Utility/transformation_tree.rst:32
msgid ""
"First configure the input (edges) in the transformation tree. Click `Set "
"Inputs` and select a pose item to edit (add or delete item if needed). "
"Set Object A name, Object B name, A in B transformation. You can click "
"`Set Pose` to manually input a pose. Click `apply` after editing."
msgstr ""

#: ../nodes/Utility/transformation_tree.rst:35
msgid ""
"Then configure the output. Click `Set output` and select a output item to"
" edit. Simply set the name of two objects and click `apply`."
msgstr ""

#: ../nodes/Utility/transformation_tree.rst:37
msgid ""
"Then run the node. You should get the expected output. The relative "
"positions of all objects are also shown in the display"
msgstr ""

#: ../nodes/index.rst:2
msgid "Nodes Detail Explanation"
msgstr ""

#: ../nodes/index.rst:4
msgid ""
"This section is a detailed description about the functionalities of each "
"node. You can also find examples here"
msgstr ""

